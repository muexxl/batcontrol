================================================================
RepopackPy Output File
================================================================

This file was generated by RepopackPy on: 2025-03-03T20:36:00.200959

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This header section
2. Repository structure
3. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
1. This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
2. When processing this file, use the separators and "File:" markers to
  distinguish between different files in the repository.
3. Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and RepopackPy's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

For more information about RepopackPy, visit: https://github.com/abinthomasonline/repopack-py

================================================================
Repository Structure
================================================================
__init__.py
__main__.py
__pkginfo__.py
core.py
dynamictariff\__init__.py
dynamictariff\awattar.py
dynamictariff\baseclass.py
dynamictariff\dynamictariff.py
dynamictariff\dynamictariff_interface.py
dynamictariff\evcc.py
dynamictariff\tibber.py
evcc_api.py
forecastconsumption\__init__.py
forecastconsumption\consumption.py
forecastconsumption\forecast_csv.py
forecastconsumption\forecastconsumption_interface.py
forecastsolar\__init__.py
forecastsolar\fcsolar.py
forecastsolar\forecastsolar_interface.py
forecastsolar\solar.py
inverter\__init__.py
inverter\baseclass.py
inverter\fronius.py
inverter\inverter.py
inverter\inverter_interface.py
inverter\testdriver.py
logfilelimiter\__init__.py
logfilelimiter\logfilelimiter.py
mqtt_api.py

================================================================
Repository Files
================================================================

================
File: core.py
================
#! /usr/bin/env python
# %%
import sys
import datetime
import time
import os
import logging
import yaml
import pytz
import numpy as np
import platform

from .mqtt_api import MqttApi
from .evcc_api import EvccApi

from .dynamictariff import DynamicTariff as tariff_factory
from .inverter import Inverter as inverter_factory
from .logfilelimiter import LogFileLimiter

from .forecastsolar import ForecastSolar as solar_factory

from .forecastconsumption import Consumption as consumption_factory


LOGFILE_ENABLED_DEFAULT = True
LOGFILE = "logs/batcontrol.log"

VALID_UTILITIES = ['tibber', 'awattar_at', 'awattar_de', 'evcc']
VALID_INVERTERS = ['fronius_gen24', 'testdriver']
ERROR_IGNORE_TIME = 600  # 10 Minutes
EVALUATIONS_EVERY_MINUTES = 3  # Every x minutes on the clock
DELAY_EVALUATION_BY_SECONDS = 15  # Delay evaluation for x seconds at every trigger
# Interval between evaluations in seconds
TIME_BETWEEN_EVALUATIONS = EVALUATIONS_EVERY_MINUTES * 60
TIME_BETWEEN_UTILITY_API_CALLS = 900  # 15 Minutes
# Minimum charge rate to controlling loops between charging and
#   self discharge.
# 500W is Fronius' internal value for forced recharge.
MIN_CHARGE_RATE = 500


MODE_ALLOW_DISCHARGING = 10
MODE_AVOID_DISCHARGING = 0
MODE_FORCE_CHARGING = -1

loglevel = logging.DEBUG
logger = logging.getLogger(__name__)
formatter = logging.Formatter("%(asctime)s %(levelname)s %(message)s",
                              "%Y-%m-%d %H:%M:%S")

streamhandler = logging.StreamHandler(sys.stdout)
streamhandler.setFormatter(formatter)

logger.addHandler(streamhandler)

logger.setLevel(loglevel)

logger.info('[Main] Starting Batcontrol')


class Batcontrol:
    def __init__(self, configfile:str):
        # For API
        self.api_overwrite = False
        # -1 = charge from grid , 0 = avoid discharge , 10 = discharge allowed
        self.last_mode = None
        self.last_charge_rate = 0
        self.last_prices = None
        self.last_consumption = None
        self.last_production = None
        self.last_net_consumption = None

        self.last_SOC = -1              # pylint: disable=invalid-name
        self.last_free_capacity = -1
        self.last_stored_energy = -1
        self.last_reserved_energy = -1
        self.last_max_capacity = -1
        self.last_stored_usable_energy = -1

        self.discharge_blocked = False
        self.discharge_limit = 0

        self.fetched_stored_energy = False
        self.fetched_reserved_energy = False
        self.fetched_max_capacity = False
        self.fetched_soc = False
        self.fetched_stored_usable_energy = False

        self.last_run_time = 0

        self.logfile = LOGFILE
        self.logfile_enabled = True
        self.logfilelimiter = None

        self.load_config(configfile)
        config = self.config

        try:
            tzstring = config['timezone']
            self.timezone = pytz.timezone(tzstring)
        except KeyError:
            raise RuntimeError(
                f"Config Entry in general: timezone {config['timezone']} " +
                "not valid. Try e.g. 'Europe/Berlin'"
            )

        try:
            tz = os.environ['TZ']
            logger.info("[Batcontrol] host system time zone is %s", tz)
        except KeyError:
            logger.info(
                "[Batcontrol] host system time zone was not set. Setting to %s",
                config['timezone']
            )
            os.environ['TZ'] = config['timezone']
        
        # time.tzset() is not available on Windows. When handling timezones exclusively using pytz this is fine
        if platform.system() != 'Windows':
            time.tzset()

        self.dynamic_tariff = tariff_factory.create_tarif_provider(
            config['utility'],
            self.timezone,
            TIME_BETWEEN_UTILITY_API_CALLS,
            DELAY_EVALUATION_BY_SECONDS
        )

        self.inverter = inverter_factory.create_inverter(
            config['inverter'])

        self.pvsettings = config['pvinstallations']
        self.fc_solar = solar_factory.create_solar_provider(
            self.pvsettings,
            self.timezone,
            DELAY_EVALUATION_BY_SECONDS
        )

        self.fc_consumption = consumption_factory.create_consumption(
            self.timezone,
            config['consumption_forecast']
        )

        self.batconfig = config['battery_control']
        self.time_at_forecast_error = -1

        self.always_allow_discharge_limit = self.batconfig['always_allow_discharge_limit']
        self.max_charging_from_grid_limit = self.batconfig['max_charging_from_grid_limit']
        self.min_price_difference = self.batconfig['min_price_difference']
        self.min_price_difference_rel = self.__get_config_with_defaults(
            self.batconfig,
            'min_price_difference_rel',
            0
        )

        self.charge_rate_multiplier = 1.1
        self.soften_price_difference_on_charging = False
        self.soften_price_difference_on_charging_factor = 5
        self.round_price_digits = 4

        if self.__is_config_key_valid(config, 'battery_control_expert'):
            battery_control_expert = self.config['battery_control_expert']
            self.soften_price_difference_on_charging = self.__get_config_with_defaults(
                battery_control_expert,
                'soften_price_difference_on_charging',
                False
            )
            self.soften_price_difference_on_charging_factor = self.__get_config_with_defaults(
                battery_control_expert,
                'soften_price_difference_on_charging_factor',
                5
            )
            self.round_price_digits = self.__get_config_with_defaults(
                battery_control_expert,
                'round_price_digits',
                4
            )
            self.charge_rate_multiplier = self.__get_config_with_defaults(
                battery_control_expert,
                'charge_rate_multiplier',
                1.1
            )

        self.charge_rate_multiplier = 1.1
        self.soften_price_difference_on_charging = False
        self.soften_price_difference_on_charging_factor = 5
        self.round_price_digits = 4

        if self.__is_config_key_valid(config, 'battery_control_expert'):
            battery_control_expert = self.config['battery_control_expert']
            self.soften_price_difference_on_charging = self.__get_config_with_defaults(
                battery_control_expert,
                'soften_price_difference_on_charging',
                False
            )
            self.soften_price_difference_on_charging_factor = self.__get_config_with_defaults(
                battery_control_expert,
                'soften_price_difference_on_charging_factor',
                5
            )
            self.round_price_digits = self.__get_config_with_defaults(
                battery_control_expert,
                'round_price_digits',
                4
            )
            self.charge_rate_multiplier = self.__get_config_with_defaults(
                battery_control_expert,
                'charge_rate_multiplier',
                1.1
            )

        self.mqtt_api = None
        if 'mqtt' in config.keys():

            if config['mqtt']['enabled']:
                logger.info('[Main] MQTT Connection enabled')
                self.mqtt_api = MqttApi(config['mqtt'])
                self.mqtt_api.wait_ready()
                # Register for callbacks
                self.mqtt_api.register_set_callback(
                    'mode',
                    self.api_set_mode,
                    int
                )
                self.mqtt_api.register_set_callback(
                    'charge_rate',
                    self.api_set_charge_rate,
                    int
                )
                self.mqtt_api.register_set_callback(
                    'always_allow_discharge_limit',
                    self.api_set_always_allow_discharge_limit,
                    float
                )
                self.mqtt_api.register_set_callback(
                    'max_charging_from_grid_limit',
                    self.api_set_max_charging_from_grid_limit,
                    float
                )
                self.mqtt_api.register_set_callback(
                    'min_price_difference',
                    self.api_set_min_price_difference,
                    float
                )
                self.mqtt_api.register_set_callback(
                    'min_price_difference_rel',
                    self.api_set_min_price_difference_rel,
                    float
                )
                # Inverter Callbacks
                self.inverter.activate_mqtt(self.mqtt_api)

        self.evcc_api = None
        if 'evcc' in config.keys():
            if config['evcc']['enabled']:
                logger.info('[Main] evcc Connection enabled')
                self.evcc_api = EvccApi(config['evcc'])
                self.evcc_api.register_block_function(
                    self.set_discharge_blocked)
                self.evcc_api.register_always_allow_discharge_limit(
                    self.set_always_allow_discharge_limit,
                    self.get_always_allow_discharge_limit
                )
                self.evcc_api.register_max_charge_limit(
                    self.set_max_charging_from_grid_limit,
                    self.get_max_charging_from_grid_limit
                )
                self.evcc_api.start()
                self.evcc_api.wait_ready()
                logger.info('[Main] evcc Connection ready')

    def shutdown(self):
        """ Shutdown Batcontrol and dependend modules (inverter..) """
        logger.info('[Main] Shutting down Batcontrol')
        try:
            self.inverter.shutdown()
            del self.inverter
            if self.evcc_api is not None:
                self.evcc_api.shutdown()
                del self.evcc_api
        except:
            pass

    def __get_config_with_defaults(self, config: dict, key: str, default):
        """ Get a key from a config dictionary with a default value """
        if key in config.keys():
            return config[key]
        return default

    def __is_config_key_valid(self, config: dict, key: str):
        """ Check if a key is in a config dictionary """
        if key in config.keys():
            return True
        return False

    def load_config(self, configfile):
        """ Load the configuration file and check for validity.
            This maps some config entries for compatibility reasons.
         """
        if not os.path.isfile(configfile):
            raise RuntimeError(f'Configfile {configfile} not found')

        with open(configfile, 'r', encoding='UTF-8') as f:
            config_str = f.read()

        config = yaml.safe_load(config_str)

        if config['utility']['type'] in VALID_UTILITIES:
            pass
        else:
            raise RuntimeError('Unkonwn Utility')

        if config['utility']['type'] == 'tibber':
            if 'apikey' in config['utility'].keys():
                pass
            else:
                raise RuntimeError(
                    '[BatCtrl] Utility Tibber requires an apikey. '
                    'Please provide the apikey in your configuration file'
                )
        elif config['utility']['type'] in ['evcc']:
            if 'url' in config['utility'].keys():
                pass
            else:
                raise RuntimeError(
                    '[BatCtrl] Utility evcc requires an URL. '
                    'Please provide the URL in your configuration file'
                )
        else:
            config['utility']['apikey'] = None

        if config['inverter']['type'] in VALID_INVERTERS:
            pass
        else:
            raise RuntimeError('Unkown inverter')

        if config['pvinstallations']:
            pass
        else:
            raise RuntimeError('No PV Installation found')

        global loglevel
        loglevel = self.__get_config_with_defaults(config, 'loglevel', 'info')

        if loglevel == 'debug':
            logger.setLevel(logging.DEBUG)
        elif loglevel == 'warning':
            logger.setLevel(logging.WARNING)
        elif loglevel == 'error':
            logger.setLevel(logging.ERROR)
        elif loglevel == 'info':
            logger.setLevel(logging.INFO)
        else:
            logger.setLevel(logging.INFO)
            logger.info(
                '[BATCtrl] Provided loglevel "%s" not valid. Defaulting to loglevel "info"',
                loglevel
            )

        log_is_enabled = self.__get_config_with_defaults(
            config,
            'logfile_enabled',
            LOGFILE_ENABLED_DEFAULT
        )
        if log_is_enabled:
            self.setup_logfile(config)
        else:
            self.logfile_enabled = False
            logger.info(
                "[Main] Logfile disabled in config. Proceeding without logfile"
            )

        self.config = config

    def setup_logfile(self, config):
        """ Setup the logfile and correpsonding handlers """

        if self.__is_config_key_valid(config, 'max_logfile_size'):
            if isinstance(config['max_logfile_size'], int):
                pass
            else:
                raise RuntimeError(
                    f"Config Entry in general: max_logfile_size {config['max_logfile_size']}" +
                    " not valid. Only integer values allowed"
                )
        # default to unlimited filesize
        else:
            config['max_logfile_size'] = -1

        if 'logfile_path' in config.keys():
            self.logfile = config['logfile_path']
        else:
            logger.info(
                "[Main] No logfile path provided. Proceeding with default logfile path: %s",
                self.logfile
            )

        if config['max_logfile_size'] > 0:
            self.logfilelimiter = LogFileLimiter(
                self.logfile, config['max_logfile_size'])

        # is the path valid and writable?
        if not os.path.isdir(os.path.dirname(self.logfile)):
            raise RuntimeError(
                f"Logfile path {os.path.dirname(self.logfile)} not found"
            )
        if not os.access(os.path.dirname(self.logfile), os.W_OK):
            raise RuntimeError(
                f"Logfile path {os.path.dirname(self.logfile)} not writable"
            )

        filehandler = logging.FileHandler(self.logfile)
        filehandler.setFormatter(formatter)
        logger.addHandler(filehandler)

    def reset_forecast_error(self):
        """ Reset the forecast error timer """
        self.time_at_forecast_error = -1

    def handle_forecast_error(self):
        """ Handle forecast errors and fallback to discharging """
        error_ts = time.time()

        # set time_at_forecast_error if it is at the default value of -1
        if self.time_at_forecast_error == -1:
            self.time_at_forecast_error = error_ts

        # get time delta since error
        time_passed = error_ts-self.time_at_forecast_error

        if time_passed < ERROR_IGNORE_TIME:
            # keep current mode
            logger.info("[BatCtrl] An API Error occured %0.fs ago. "
                        "Keeping inverter mode unchanged.", time_passed)
        else:
            # set default mode
            logger.warning(
                "[BatCtrl] An API Error occured %0.fs ago. "
                "Setting inverter to default mode (Allow Discharging)",
                time_passed)
            self.allow_discharging()

    def run(self):
        """ Main calculation & control loop """
        # Reset some values
        self.__reset_run_data()

        # Verify some constrains:
        #   always_allow_discharge needs to be above max_charging from grid.
        #   if not, it will oscillate between discharging and charging.
        if self.always_allow_discharge_limit < self.max_charging_from_grid_limit:
            logger.warning("[BatCtrl] always_allow_discharge_limit (%.2f) is"
                           " below max_charging_from_grid_limit (%.2f)",
                            self.always_allow_discharge_limit ,
                            self.max_charging_from_grid_limit
                           )
            self.max_charging_from_grid_limit = self.always_allow_discharge_limit - 0.01
            logger.warning("[BatCtrl] Lowering max_charging_from_grid_limit to %.2f" ,
                           self.max_charging_from_grid_limit )

        # for API
        self.refresh_static_values()
        self.set_discharge_limit(
            self.get_max_capacity() * self.always_allow_discharge_limit
        )
        self.last_run_time = time.time()

        # prune log file if file is too large
        if self.logfilelimiter is not None and self.logfile_enabled:
            self.logfilelimiter.run()

        # get forecasts
        try:
            price_dict = self.dynamic_tariff.get_prices()
            production_forecast = self.fc_solar.get_forecast()
            # harmonize forecast horizon
            fc_period = min(max(price_dict.keys()),
                            max(production_forecast.keys()))
            consumption_forecast = self.fc_consumption.get_forecast(
                fc_period+1)
        except Exception as e:
            logger.warning(
                '[BatCtrl] Following Exception occurred when trying to get forecasts: %s', e,
                exc_info=True
            )
            self.handle_forecast_error()
            return

        self.reset_forecast_error()

        # initialize arrays
        net_consumption = np.zeros(fc_period+1)
        production = np.zeros(fc_period+1)
        consumption = np.zeros(fc_period+1)
        prices = np.zeros(fc_period+1)

        for h in range(fc_period+1):
            production[h] = production_forecast[h]
            consumption[h] = consumption_forecast[h]
            prices[h] = round(price_dict[h], self.round_price_digits)

        net_consumption = consumption-production
        logger.debug('[BatCTRL] Production FCST: %s',
                     np.ndarray.round(production, 1))
        logger.debug('[BatCTRL] Consumption FCST: %s',
                     np.ndarray.round(consumption, 1))
        logger.debug('[BatCTRL] Net Consumption FCST: %s',
                     np.ndarray.round(net_consumption, 1))
        logger.debug('[BatCTRL] Prices: %s', np.ndarray.round(
            prices, self.round_price_digits))
        # negative = charging or feed in
        # positive = dis-charging or grid consumption

        # Store data for API
        self.__save_run_data(production, consumption, net_consumption, prices)

        # stop here if api_overwrite is set and reset it
        if self.api_overwrite:
            logger.info(
                '[BatCTRL] API Overwrite active. Skipping control logic. '
                'Next evaluation in %.0f seconds',
                TIME_BETWEEN_EVALUATIONS
            )
            self.api_overwrite = False
            return

        # correction for time that has already passed since the start of the current hour
        net_consumption[0] *= 1 - \
            datetime.datetime.now().astimezone(self.timezone).minute/60

        self.set_wr_parameters(net_consumption, price_dict)

        # %%
    def set_wr_parameters(self, net_consumption: np.ndarray, prices: dict):
        """ Main control logic for battery control """
        # ensure availability of data
        max_hour = min(len(net_consumption), len(prices))

        if self.is_discharge_allowed(net_consumption, prices):
            self.allow_discharging()
        else:  # discharge not allowed
            logger.debug('[Rule] Discharging is NOT allowed')
            charging_limit_percent = self.max_charging_from_grid_limit * 100
            required_recharge_energy = self.get_required_required_recharge_energy(
                net_consumption[:max_hour],
                prices
            )
            is_charging_possible = self.get_SOC() < charging_limit_percent

            logger.debug('[BatCTRL] Charging allowed: %s',
                         is_charging_possible)
            if is_charging_possible:
                logger.debug('[Rule] Charging is allowed, because SOC is below %.0f%%',
                             charging_limit_percent
                             )
            else:
                logger.debug('[Rule] Charging is NOT allowed, because SOC is above %.0f%%',
                             charging_limit_percent
                             )

            if required_recharge_energy > 0:
                logger.debug(
                    '[BatCTRL] Get additional energy via grid: %0.1f Wh',
                    required_recharge_energy
                )
            else:
                logger.debug(
                    '[Rule] No additional energy required or possible price found.')

            # charge if battery capacity available and more stored energy is required
            if is_charging_possible and required_recharge_energy > 0:
                remaining_time = (
                    60-datetime.datetime.now().astimezone(self.timezone).minute)/60
                charge_rate = required_recharge_energy/remaining_time
                # apply multiplier for charge inefficiency
                charge_rate *= self.charge_rate_multiplier

                if charge_rate < MIN_CHARGE_RATE:
                    logger.debug("[Rule] Charge rate increased to minimum %d W from %f.1 W",
                                 MIN_CHARGE_RATE,
                                 charge_rate
                                 )
                    charge_rate = MIN_CHARGE_RATE

                self.force_charge(charge_rate)

            else:  # keep current charge level. recharge if solar surplus available
                self.avoid_discharging()

    # %%
    def get_required_required_recharge_energy(self, net_consumption: list, prices: dict) -> float:
        """ Calculate the required energy to shift toward high price hours.

            If a recharge price window is detected, the energy required to
            recharge the battery to the next high price hours is calculated.

            return: float (Energy in Wh)
         """
        current_price = prices[0]
        max_hour = len(net_consumption)
        consumption = np.array(net_consumption)
        consumption[consumption < 0] = 0

        production = -np.array(net_consumption)
        production[production < 0] = 0
        min_price_difference = self.min_price_difference
        min_dynamic_price_difference = self.__calculate_min_dynamic_price_difference(
            current_price)

        # evaluation period until price is first time lower then current price
        for h in range(1, max_hour):
            future_price = prices[h]
            found_lower_price = False
            # Soften the price difference to avoid too early charging
            if self.soften_price_difference_on_charging:
                modified_price = current_price-min_price_difference / \
                    self.soften_price_difference_on_charging_factor
                found_lower_price = future_price <= modified_price
            else:
                found_lower_price = future_price <= current_price

            if found_lower_price:
                max_hour = h
                break

        # get high price hours
        high_price_hours = []
        for h in range(max_hour):
            future_price = prices[h]
            if future_price > current_price+min_dynamic_price_difference:
                high_price_hours.append(h)

        # start with nearest hour
        high_price_hours.sort()
        required_energy = 0
        for high_price_hour in high_price_hours:
            energy_to_shift = consumption[high_price_hour]

            # correct energy to shift with potential production
            # start with nearest hour
            for hour in range(1, high_price_hour):
                if production[hour] == 0:
                    continue
                if production[hour] >= energy_to_shift:
                    production[hour] -= energy_to_shift
                    energy_to_shift = 0
                else:
                    energy_to_shift -= production[hour]
                    production[hour] = 0
            # add_remaining energy to shift to recharge amount
            required_energy += energy_to_shift

        if required_energy > 0:
            logger.debug("[Rule] Required Energy: %0.1f Wh is based on next 'high price' hours %s",
                         required_energy,
                         high_price_hours
                         )
            recharge_energy = required_energy-self.get_stored_usable_energy()
            logger.debug("[Rule] Stored usable Energy: %0.1f , Recharge Energy: %0.1f Wh",
                         self.get_stored_usable_energy(),
                         recharge_energy
                         )
        else:
            recharge_energy = 0

        free_capacity = self.get_free_capacity()

        if recharge_energy <= 0:
            logger.debug(
                "[Rule] No additional energy required, because stored energy is sufficient."
            )
            recharge_energy = 0

        if recharge_energy > free_capacity:
            recharge_energy = free_capacity
            logger.debug(
                "[Rule] Recharge limited by free capacity: %0.1f Wh", recharge_energy)

        return recharge_energy

    def __is_above_always_allow_discharge_limit(self) -> bool:
        """ Evaluate if the battery is allowed to discharge always
            return: bool
        """
        stored_energy = self.get_stored_energy()
        discharge_limit = self.get_max_capacity() * self.always_allow_discharge_limit
        if stored_energy > discharge_limit:
            logger.debug(
                '[BatCTRL] Battery with %d Wh above discharge limit %d Wh',
                stored_energy,
                discharge_limit
            )
            return True
        return False
# %%

    def is_discharge_allowed(self, net_consumption: np.ndarray, prices: dict) -> bool:
        """ Evaluate if the battery is allowed to discharge

            - Check if battery is above always_allow_discharge_limit
            - Calculate required energy to shift toward high price hours
            - Check if discharge is blocked by external source

            return: bool
        """
        self.get_stored_energy()
        stored_usable_energy = self.get_stored_usable_energy()

        if self.__is_above_always_allow_discharge_limit():
            logger.info(
                "[Rule] Discharge allowed due to always_allow_discharge_limit")
            return True

        current_price = prices[0]

        min_dynamic_price_difference = self.__calculate_min_dynamic_price_difference(
            current_price)
        if self.mqtt_api is not None:
            self.mqtt_api.publish_min_dynamic_price_diff(
                min_dynamic_price_difference)

        max_hour = len(net_consumption)
        # relevant time range : until next recharge possibility
        for h in range(1, max_hour):
            future_price = prices[h]
            if future_price <= current_price-min_dynamic_price_difference:
                max_hour = h
                logger.debug(
                    "[Rule] Recharge possible in %d hours, limiting evaluation window.",
                    h)
                logger.debug(
                    "[Rule] Future price: %.3f < Current price: %.3f - dyn_price_diff. %.3f ",
                    future_price,
                    current_price,
                    min_dynamic_price_difference
                )
                break
        dt = datetime.timedelta(hours=max_hour-1)
        t0 = datetime.datetime.now()
        t1 = t0+dt
        last_hour = t1.astimezone(self.timezone).strftime("%H:59")

        logger.debug(
            '[Rule] Evaluating next %d hours until %s',
            max_hour,
            last_hour
        )
        # distribute remaining energy
        consumption = np.array(net_consumption)
        consumption[consumption < 0] = 0

        production = -np.array(net_consumption)
        production[production < 0] = 0

        # get hours with higher price
        higher_price_hours = []
        for h in range(max_hour):
            future_price = prices[h]
            # !!! different formula compared to detect relevant hours
            if future_price > current_price:
                higher_price_hours.append(h)

        higher_price_hours.sort()
        higher_price_hours.reverse()

        reserved_storage = 0
        for higher_price_hour in higher_price_hours:
            if consumption[higher_price_hour] == 0:
                continue
            required_energy = consumption[higher_price_hour]

            # correct reserved_storage with potential production
            # start with latest hour
            for hour in list(range(higher_price_hour))[::-1]:
                if production[hour] == 0:
                    continue
                if production[hour] >= required_energy:
                    production[hour] -= required_energy
                    required_energy = 0
                    break
                else:
                    required_energy -= production[hour]
                    production[hour] = 0
            # add_remaining required_energy to reserved_storage
            reserved_storage += required_energy

        if len(higher_price_hours) > 0:
            # This message is somehow confusing, because we are working with an
            # hour offset "the next 2 hours", but people may read "2 o'clock".
            logger.debug("[Rule] Reserved Energy will be used in the next hours: %s",
                         higher_price_hours[::-1])
            logger.debug(
                "[Rule] Reserved Energy: %0.1f Wh. Usable in Battery: %0.1f Wh",
                reserved_storage,
                stored_usable_energy
            )
        else:
            logger.debug("[Rule] No reserved energy required, because no "
                         "'high price' hours in evaluation window.")

        # for API
        self.set_reserved_energy(reserved_storage)

        if self.discharge_blocked:
            logger.debug(
                '[BatCTRL] Discharge blocked due to external lock'
            )
            return False

        if stored_usable_energy > reserved_storage:
            # allow discharging
            logger.debug(
                "[Rule] Discharge allowed. Stored usable energy %0.1f Wh >"
                " Reserved energy %0.1f Wh",
                stored_usable_energy,
                reserved_storage
            )
            return True

        # forbid discharging
        logger.debug(
            "[Rule] Discharge forbidden. Stored usable energy %0.1f Wh <= Reserved energy %0.1f Wh",
            stored_usable_energy,
            reserved_storage
        )

        return False

    def __calculate_min_dynamic_price_difference(self, price: float) -> float:
        """ Calculate the dynamic limit for the current price """
        return round(
            max(self.min_price_difference,
                self.min_price_difference_rel * abs(price)),
            self.round_price_digits
        )

    def __set_charge_rate(self, charge_rate: int):
        """ Set charge rate and publish to mqtt """
        self.last_charge_rate = charge_rate
        if self.mqtt_api is not None:
            self.mqtt_api.publish_charge_rate(charge_rate)

    def __set_mode(self, mode):
        """ Set mode and publish to mqtt """
        self.last_mode = mode
        if self.mqtt_api is not None:
            self.mqtt_api.publish_mode(mode)
        # leaving force charge mode, reset charge rate
        if self.last_charge_rate > 0 and mode != MODE_FORCE_CHARGING:
            self.__set_charge_rate(0)

    def allow_discharging(self):
        """ Allow unlimited discharging of the battery """
        logger.info('[BatCTRL] Mode: Allow Discharging')
        self.inverter.set_mode_allow_discharge()
        self.__set_mode(MODE_ALLOW_DISCHARGING)

    def avoid_discharging(self):
        """ Avoid discharging the battery """
        logger.info('[BatCTRL] Mode: Avoid Discharging')
        self.inverter.set_mode_avoid_discharge()
        self.__set_mode(MODE_AVOID_DISCHARGING)

    def force_charge(self, charge_rate=500):
        """ Force the battery to charge with a given rate """
        charge_rate = int(min(charge_rate, self.inverter.max_grid_charge_rate))
        logger.info(
            '[BatCTRL] Mode: grid charging. Charge rate : %d W', charge_rate)
        self.inverter.set_mode_force_charge(charge_rate)
        self.__set_mode(MODE_FORCE_CHARGING)
        self.__set_charge_rate(charge_rate)

    def __save_run_data(self, production, consumption, net_consumption, prices):
        """ Save data for API """
        self.last_production = production
        self.last_consumption = consumption
        self.last_net_consumption = net_consumption
        self.last_prices = prices
        if self.mqtt_api is not None:
            self.mqtt_api.publish_production(production, self.last_run_time)
            self.mqtt_api.publish_consumption(consumption, self.last_run_time)
            self.mqtt_api.publish_net_consumption(
                net_consumption, self.last_run_time)
            self.mqtt_api.publish_prices(prices, self.last_run_time)

    def __reset_run_data(self):
        """ Reset value Cache """
        self.fetched_soc = False
        self.fetched_max_capacity = False
        self.fetched_stored_energy = False
        self.fetched_reserved_energy = False
        self.fetched_stored_usable_energy = False

    def get_SOC(self) -> float:  # pylint: disable=invalid-name
        """ Returns the SOC in % (0-100) , collects data from inverter """
        if not self.fetched_soc:
            self.last_SOC = self.inverter.get_SOC()
            # self.last_SOC = self.get_stored_energy() / self.get_max_capacity() * 100
            self.fetched_soc = True
        return self.last_SOC

    def get_max_capacity(self) -> float:
        """ Returns capacity Wh of all batteries reduced by MAX_SOC """
        if not self.fetched_max_capacity:
            self.last_max_capacity = self.inverter.get_max_capacity()
            self.fetched_max_capacity = True
            if self.mqtt_api is not None:
                self.mqtt_api.publish_max_energy_capacity(
                    self.last_max_capacity)
        return self.last_max_capacity

    def get_stored_energy(self) -> float:
        """ Returns the stored eneregy in the battery in kWh without
            considering the minimum SOC"""
        if not self.fetched_stored_energy:
            self.set_stored_energy(self.inverter.get_stored_energy())
            self.fetched_stored_energy = True
        return self.last_stored_energy

    def get_stored_usable_energy(self) -> float:
        """ Returns the stored eneregy in the battery in kWh with considering
            the MIN_SOC of inverters. """
        if not self.fetched_stored_usable_energy:
            self.set_stored_usable_energy(
                self.inverter.get_stored_usable_energy())
            self.fetched_stored_usable_energy = True
        return self.last_stored_usable_energy

    def get_free_capacity(self) -> float:
        """ Returns the free capacity in Wh that is usable for (dis)charging """
        self.last_free_capacity = self.inverter.get_free_capacity()
        return self.last_free_capacity

    def set_reserved_energy(self, reserved_energy) -> None:
        """ Set the reserved energy in Wh """
        self.last_reserved_energy = reserved_energy
        if self.mqtt_api is not None:
            self.mqtt_api.publish_reserved_energy_capacity(reserved_energy)

    def get_reserved_energy(self) -> float:
        """ Returns the reserved energy in Wh from last calculation """
        return self.last_reserved_energy

    def set_stored_energy(self, stored_energy) -> None:
        """ Set the stored energy in Wh """
        self.last_stored_energy = stored_energy
        if self.mqtt_api is not None:
            self.mqtt_api.publish_stored_energy_capacity(stored_energy)

    def set_stored_usable_energy(self, stored_usable_energy) -> None:
        """ Saves the stored usable energy for API
            This is the energy that can be used for discharging. This takes
            account of MIN_SOC and MAX_SOC.
        """
        self.last_stored_usable_energy = stored_usable_energy
        if self.mqtt_api is not None:
            self.mqtt_api.publish_stored_usable_energy_capacity(
                stored_usable_energy)

    def set_discharge_limit(self, discharge_limit) -> None:
        """ Sets the always_allow_discharge_limit and publishes it to the API.
            This is the value in Wh.
        """
        self.discharge_limit = discharge_limit
        if self.mqtt_api is not None:
            self.mqtt_api.publish_always_allow_discharge_limit_capacity(
                discharge_limit)

    def set_always_allow_discharge_limit(self, always_allow_discharge_limit: float) -> None:
        """ Set the always allow discharge limit for battery control """
        self.always_allow_discharge_limit = always_allow_discharge_limit
        if self.mqtt_api is not None:
            self.mqtt_api.publish_always_allow_discharge_limit(
                always_allow_discharge_limit)

    def get_always_allow_discharge_limit(self) -> float:
        """ Get the always allow discharge limit for battery control """
        return self.always_allow_discharge_limit

    def set_max_charging_from_grid_limit(self, limit: float) -> None:
        """ Set the max charging from grid limit for battery control """
        # tbh , we should raise an exception here.
        if limit > self.get_always_allow_discharge_limit():
            logger.error(
                '[BatCtrl] Max charging from grid limit %.2f is '
                'above always_allow_discharge_limit %.2f',
                limit,
                self.get_always_allow_discharge_limit()
            )
            return
        self.max_charging_from_grid_limit = limit
        if self.mqtt_api is not None:
            self.mqtt_api.publish_max_charging_from_grid_limit(limit)

    def get_max_charging_from_grid_limit(self) -> float:
        """ Get the max charging from grid limit for battery control """
        return self.max_charging_from_grid_limit

    def set_discharge_blocked(self, discharge_blocked) -> None:
        """ Avoid discharging if an external block is received,
            but take care of the always_allow_discharge_limit.

            If block is removed, the next calculation cycle will
            decide what to do.
        """
        if discharge_blocked == self.discharge_blocked:
            return
        logger.info('[BatCTRL] Discharge block: %s', {discharge_blocked})
        if self.mqtt_api is not None:
            self.mqtt_api.publish_discharge_blocked(discharge_blocked)
        self.discharge_blocked = discharge_blocked

        if not self.__is_above_always_allow_discharge_limit():
            self.avoid_discharging()

    def refresh_static_values(self) -> None:
        """ Refresh static and some dynamic values for API.
            Collected data is stored, that it is not fetched again.
        """
        if self.mqtt_api is not None:
            self.mqtt_api.publish_SOC(self.get_SOC())
            self.mqtt_api.publish_stored_energy_capacity(
                self.get_stored_energy())
            #
            self.mqtt_api.publish_always_allow_discharge_limit(
                self.always_allow_discharge_limit)
            self.mqtt_api.publish_max_charging_from_grid_limit(
                self.max_charging_from_grid_limit)
            #
            self.mqtt_api.publish_min_price_difference(
                self.min_price_difference)
            self.mqtt_api.publish_min_price_difference_rel(
                self.min_price_difference_rel)
            #
            self.mqtt_api.publish_evaluation_intervall(
                TIME_BETWEEN_EVALUATIONS)
            self.mqtt_api.publish_last_evaluation_time(self.last_run_time)
            #
            self.mqtt_api.publish_discharge_blocked(self.discharge_blocked)
            # Trigger Inverter
            self.inverter.refresh_api_values()

    def api_set_mode(self, mode: int):
        """ Log and change config run mode of inverter(s) from external call """
        # Check if mode is valid
        if mode not in [MODE_FORCE_CHARGING, MODE_AVOID_DISCHARGING, MODE_ALLOW_DISCHARGING]:
            logger.warning('[BatCtrl] API: Invalid mode %s', mode)
            return

        logger.info('[BatCtrl] API: Setting mode to %s', mode)
        self.api_overwrite = True

        if mode != self.last_mode:
            if mode == MODE_FORCE_CHARGING:
                self.force_charge()
            elif mode == MODE_AVOID_DISCHARGING:
                self.avoid_discharging()
            elif mode == MODE_ALLOW_DISCHARGING:
                self.allow_discharging()

    def api_set_charge_rate(self, charge_rate: int):
        """ Log and change config charge_rate and activate charging."""
        if charge_rate < 0:
            logger.warning(
                '[BatCtrl] API: Invalid charge rate %d W', charge_rate)
            return
        logger.info('[BatCtrl] API: Setting charge rate to %d W',  charge_rate)
        self.api_overwrite = True
        if charge_rate != self.last_charge_rate:
            self.force_charge(charge_rate)

    def api_set_always_allow_discharge_limit(self, limit: float):
        """ Set always allow discharge limit for battery control via external API request.
            The change is temporary and will not be written to the config file.
        """
        if limit < 0 or limit > 1:
            logger.warning(
                '[BatCtrl] API: Invalid always allow discharge limit %.2f', limit)
            return
        logger.info(
            '[BatCtrl] API: Setting always allow discharge limit to %.2f', limit)
        self.set_always_allow_discharge_limit(limit)

    def api_set_max_charging_from_grid_limit(self, limit: float):
        """ Set max charging from grid limit for battery control via external API request.
            The change is temporary and will not be written to the config file.
        """
        if limit < 0 or limit > 1:
            logger.warning(
                '[BatCtrl] API: Invalid max charging from grid limit %.2f', limit)
            return
        logger.info(
            '[BatCtrl] API: Setting max charging from grid limit to %.2f', limit)
        self.set_max_charging_from_grid_limit(limit)

    def api_set_min_price_difference(self, min_price_difference: float):
        """ Set min price difference for battery control via external API request.
            The change is temporary and will not be written to the config file.
        """
        if min_price_difference < 0:
            logger.warning(
                '[BatCtrl] API: Invalid min price difference %.3f', min_price_difference)
            return
        logger.info(
            '[BatCtrl] API: Setting min price difference to %.3f', min_price_difference)
        self.min_price_difference = min_price_difference

    def api_set_min_price_difference_rel(self, min_price_difference_rel: float):
        """ Log and change config min_price_difference_rel from external call """
        if min_price_difference_rel < 0:
            logger.warning(
                '[BatCtrl] API: Invalid min price rel difference %.3f', min_price_difference_rel)
            return
        logger.info(
            '[BatCtrl] API: Setting min price rel difference to %.3f', min_price_difference_rel)
        self.min_price_difference_rel = min_price_difference_rel

================
File: evcc_api.py
================
"""
This module provides the EvccApi class for interacting with an
evcc (Electric Vehicle Charging Controller) via MQTT.
"""
import time
import re
import logging
import paho.mqtt.client as mqtt

logger = logging.getLogger('__main__').getChild("evcc")
logger.info('[evcc] loading module')


class EvccApi():
    """
    A class to interact with the evcc (Electric Vehicle Charging Controller) via MQTT.

    Attributes:
        config (dict): Configuration dictionary containing MQTT broker details, topics.
        evcc_is_online (bool): Internal state indicating if evcc is online.
        evcc_is_charging (bool): Internal state indicating if evcc is charging.
        evcc_batter_halt_soc (int): BufferSOC value from evcc.
        battery_halt_soc_float (float): BufferSOC value as float.
        block_function (function): Function to be called to block/unblock Battery.
        set_always_allow_discharge_limit_function (function): Function to set the discharge limit.
        get_always_allow_discharge_limit_function (function): Function to get the discharge limit.
        evcc_loadpoint_status (dict): Internal state to store the loadpoint status.
        topic_status (str): MQTT topic for evcc status messages.
        topic_loadpoint (str): MQTT topic for evcc loadpoint messages.
        topic_battery_halt_soc (str): MQTT topic for evcc battery SOC threshold.
        client (mqtt.Client): MQTT client instance.
        align_battery_load_thresshold (bool): If set, use evcc/site/bufferSoc as
                                              discharge_allow_threshold while charging.
        old_allow_discharge_limit (int): Old discharge_allow_threshold value.

    Methods:
        __init__(config: dict):
            Initializes the EvccApi instance with the given configuration.

        wait_ready() -> bool:
            Waits until the MQTT client is connected to the broker.

        register_block_function(function):
            Registers a function to be called to block/unblock charging.

        register_always_allow_discharge_limit(setter, getter):
            Registers a function to set and get the discharge limit while charging

        register_max_charge_limit(setter, getter):
            Registers a function to set and get the max charge limit while charging

        set_evcc_online(online: bool):
            Sets the evcc online status and handles state changes.

        set_evcc_charging(charging: bool):
            Sets the evcc charging status and handles state changes.

        handle_status_messages(message):
            Handles incoming status messages from the MQTT broker.

        handle_charging_message(message):
            Handles incoming charging messages from the MQTT broker.

        handle_battery_halt_soc(message):
            Handles incoming evcc config messages from the MQTT broker.

        _handle_message(client, userdata, message):
            Internal callback function to handle incoming MQTT messages.
    """

    def __init__(self, config: dict):
        self.config = config

        # internal state
        self.evcc_is_online = False
        self.evcc_is_charging = False

        self.evcc_loadpoint_status = {}

        self.block_function = None
        self.set_always_allow_discharge_limit_function = None
        self.get_always_allow_discharge_limit_function = None
        self.set_max_charge_limit_function = None
        self.get_max_charge_limit_function = None

        self.topic_status = config['status_topic']
        self.list_topics_loadpoint = []
        self.topic_battery_halt_soc = config.get(
            'battery_halt_topic', None)
        self.evcc_battery_halt_soc = None
        self.battery_halt_soc_float = None
        self.old_allow_discharge_limit = None
        self.old_max_charge_limit = None

        if isinstance(config['loadpoint_topic'], str):
            self.list_topics_loadpoint.append(config['loadpoint_topic'])
        elif isinstance(config['loadpoint_topic'], list):
            self.list_topics_loadpoint = config['loadpoint_topic']
        else:
            logger.error('[evcc] Invalid loadpoint_topic type')

        self.client = mqtt.Client(clean_session=True)

        if 'logger' in config and config['logger'] is True:
            self.client.enable_logger(logger)

        if 'username' in config and 'password' in config:
            self.client.username_pw_set(config['username'], config['password'])

        # TLS , not tested yet
        if config['tls'] is True:
            self.client.tls_set(
                config['tls']['ca_certs'],
                config['tls']['certfile'],
                config['tls']['keyfile'],
                cert_reqs=config['tls']['cert_reqs'],
                tls_version=config['tls']['tls_version'],
                ciphers=config['tls']['ciphers']
            )

        # Register callback functions, survives reconnects
        self.client.message_callback_add(
            self.topic_status, self._handle_message)
        if self.topic_battery_halt_soc is not None:
            logger.info('[evcc] Enabling battery threshold management.')
            self.client.message_callback_add(
                self.topic_battery_halt_soc, self._handle_message)
        for topic in self.list_topics_loadpoint:
            self.__store_loadpoint_status(topic, False)
            self.client.message_callback_add(topic, self._handle_message)

        self.client.on_connect = self.on_connect

    def start(self):
        """ Start MQTT connection after all init is completed"""
        self.client.loop_start()
        self.client.connect(self.config['broker'], self.config['port'], 60)
        self.wait_ready()

    def shutdown(self):
        """ Shutdown the evcc mqtt client """
        self.client.unsubscribe(self.topic_status)
        if self.topic_battery_halt_soc is not None:
            self.client.unsubscribe(self.topic_battery_halt_soc)
        for topic in self.list_topics_loadpoint:
            self.client.unsubscribe(topic)
        self.client.loop_stop()
        self.client.disconnect()

    def on_connect(self, client, userdata, flags, rc):  # pylint: disable=unused-argument
        """ Callback function for MQTT on_connect """
        logger.info('[evcc] Connected to MQTT Broker with result code %s', rc)
        # Subscribe to status and loadpoint(s)
        self.client.subscribe(self.topic_status, qos=1)
        if self.topic_battery_halt_soc is not None:
            self.client.subscribe(self.topic_battery_halt_soc, qos=1)
        for topic in self.list_topics_loadpoint:
            logger.info('[evcc] Subscribing to %s', topic)
            self.client.subscribe(topic)

    def wait_ready(self) -> bool:
        """ Wait until the MQTT client is connected to the broker """
        retry = 30
        # Check if we are connected and wait for it
        while self.client.is_connected() is False:
            retry -= 1
            if retry == 0:
                logger.error('[evcc] Could not connect to MQTT Broker')
                return False
            logger.info('[evcc] Waiting for connection')
            time.sleep(1)
        return True

    def register_block_function(self, function):
        """ Register a function to be called to block/unblock battery while charging """
        self.block_function = function

    def register_always_allow_discharge_limit(self, setter, getter):
        """ Register a function to set and get the discharge limit while charging """
        self.set_always_allow_discharge_limit_function = setter
        self.get_always_allow_discharge_limit_function = getter

    def register_max_charge_limit(self, setter, getter):
        """ Register a function to set and get the max charge limit while charging """
        self.set_max_charge_limit_function = setter
        self.get_max_charge_limit_function = getter

    def __save_old_allow_discharge_limit(self):
        """ Save old limit, if not already set."""
        if self.old_allow_discharge_limit is None:
            self.old_allow_discharge_limit = self.get_always_allow_discharge_limit_function()
        if self.old_max_charge_limit is None:
            self.old_max_charge_limit = self.get_max_charge_limit_function()
            if self.old_max_charge_limit < self.battery_halt_soc_float:
                # Only store if the old value is higher than the new battery_hold one,
                # which will may be altered by batcontrol to a lower value.
                self.old_max_charge_limit = None

    def __restore_old_allow_discharge_limit(self):
        """ Restore old limit, if set and set to None """
        if not self.old_allow_discharge_limit is None:
            logger.info("[evcc] Restoring allow_discharge_limit %.2f",
                        self.old_allow_discharge_limit)
            self.set_always_allow_discharge_limit_function(
                self.old_allow_discharge_limit)
            self.old_allow_discharge_limit = None
        # This value may be changed, too, so we restore it
        if not self.old_max_charge_limit is None:
            logger.info("[evcc] Restoring max_charge_limit %.2f",
                        self.old_max_charge_limit)
            self.set_max_charge_limit_function(self.old_max_charge_limit)
            self.old_max_charge_limit = None

    def set_evcc_discharge_limit_on_batcontrol(self):
        """ Set allow_discharge_limit on batcontrol"""
        if self.evcc_battery_halt_soc is not None:
            logger.info('[evcc] Setting always_allow_discharge_limit to %.2f',
                        self.battery_halt_soc_float)
            self.set_always_allow_discharge_limit_function(
                self.battery_halt_soc_float
            )
        else:
            logger.error('[evcc] No evcc battery hold config value received')

    def set_evcc_online(self, online: bool):
        """ Set the evcc online status and handle state changes.
            If the evcc goes offline while charging, we remove an existing block.
        """
        if self.evcc_is_online != online:
            if online is False:
                logger.error('[evcc] evcc went offline')
                if self.evcc_is_charging is True:
                    # We remove the block, that we set to not end endless in block mode
                    logger.error('[evcc] evcc was charging, remove block')
                    self.evcc_is_charging = False
                    self.block_function(False)
                    self.__restore_old_allow_discharge_limit()
                    self.__reset_loadpoint_status()
            else:
                logger.info('[evcc] evcc is online')
            self.evcc_is_online = online

    def set_evcc_charging(self, charging: bool):
        """ Set the evcc charging status and handle state changes """
        if self.evcc_is_charging != charging:
            if charging is True:
                # We set the block, so we do not discharge the battery
                logger.info('[evcc] evcc is charging, set block')
                self.evcc_is_charging = True
                self.block_function(True)
                if self.topic_battery_halt_soc is not None:
                    self.__save_old_allow_discharge_limit()
                    self.set_evcc_discharge_limit_on_batcontrol()
            else:
                logger.info('[evcc] evcc is not charging, remove block')
                self.evcc_is_charging = False
                self.block_function(False)
                self.__restore_old_allow_discharge_limit()
        self.evcc_is_charging = charging

    def __store_loadpoint_status(self, topic: str, is_charging: bool):
        """ Store the loadpoint status """
        send_info = False
        if topic not in self.evcc_loadpoint_status:
            self.evcc_loadpoint_status[topic] = is_charging
            send_info = True
        if self.evcc_loadpoint_status[topic] != is_charging:
            self.evcc_loadpoint_status[topic] = is_charging
            send_info = True
        # Send info if status changed
        if send_info is True:
            if is_charging is False:
                logger.info('[evcc] Loadpoint %s is not charging.', topic)
            else:
                logger.info('[evcc] Loadpoint %s is charging.', topic)

    def __reset_loadpoint_status(self):
        """ Reset the loadpoint status """
        for topic in self.list_topics_loadpoint:
            self.evcc_loadpoint_status[topic] = False

    def handle_status_messages(self, message):
        """ Handle incoming status messages from the MQTT broker """
        # logger.debug('[evcc] Received status message: %s', message.payload)
        if message.payload == b'online':
            self.set_evcc_online(True)
        elif message.payload == b'offline':
            self.set_evcc_online(False)

    def handle_battery_halt_soc(self, message):
        """ Handling incoming config message, change if needed. """
        if message.payload == b'':
            # Initial Messages from evcc on restart.
            return
        try:
            new_soc = int(message.payload)
            if self.evcc_battery_halt_soc is None or \
               self.evcc_battery_halt_soc != new_soc:
                self.evcc_battery_halt_soc = new_soc
                logger.info('[evcc] New bufferSOC value: %s', new_soc)
                self.battery_halt_soc_float = new_soc / 100
                if self.evcc_is_charging is True:
                    self.set_always_allow_discharge_limit_function(
                        self.battery_halt_soc_float)
        except ValueError:
            logger.error('[evcc] Could not convert bufferSOC to int')

    def handle_charging_message(self, message):
        """ Handle incoming charging messages from the MQTT broker """
        if message.payload == b'':
            # Initial Messages from evcc on restart.
            return
        if re.match(b'true', message.payload, re.IGNORECASE):
            self.__store_loadpoint_status(message.topic, True)
        elif re.match(b'false', message.payload, re.IGNORECASE):
            self.__store_loadpoint_status(message.topic, False)

        self.evaluate_charging_status()

    def evaluate_charging_status(self):
        """ Go through the loadpoints and check if one is charging """
        for _, is_charging in self.evcc_loadpoint_status.items():
            if is_charging is True:
                self.set_evcc_charging(True)
                return
        self.set_evcc_charging(False)

    def _handle_message(self, client, userdata, message):  # pylint: disable=unused-argument
        """ Message dispatching function """
        # logger.debug('[evcc] Received message on %s', message.topic)
        if message.topic == self.topic_status:
            self.handle_status_messages(message)
        elif self.topic_battery_halt_soc is not None and \
                message.topic == self.topic_battery_halt_soc:
            self.handle_battery_halt_soc(message)
        # Check if message.topic is in self.list_topics_loadpoint
        elif message.topic in self.list_topics_loadpoint:
            self.handle_charging_message(message)
        else:
            logger.warning(
                '[evcc] No callback registered for %s', message.topic)

================
File: mqtt_api.py
================
"""
This module provides an API to publish data from batcontrol to MQTT
for further processing and visualization.

The following topics are published:
- /status: online/offline status of batcontrol
- /evaluation_intervall: interval in seconds
- /last_evaluation: timestamp of last evaluation
- /mode: operational mode (-1 = charge from grid, 0 = avoid discharge, 10 = discharge allowed)
- /max_charging_from_grid_limit: charge limit in 0.1-1
- /max_charging_from_grid_limit_percent: charge limit in %
- /always_allow_discharge_limit: always discharge limit in 0.1-1
- /always_allow_discharge_limit_percent: always discharge limit in %
- /always_allow_discharge_limit_capacity: always discharge limit in Wh
- /charge_rate: charge rate in W
- /max_energy_capacity: maximum capacity of battery in Wh
- /stored_energy_capacity: energy stored in battery in Wh
- /stored_usable_energy_capacity: energy stored in battery in Wh and usable (min SOC considered)
- /reserved_energy_capacity: estimated energy reserved for discharge in Wh
- /SOC: state of charge in %
- /min_price_difference : minimum price difference in EUR
- /discharge_blocked        : bool  # Discharge is blocked by other sources

The following statistical arrays are published as JSON arrays:
- /FCST/production: forecasted production in W
- /FCST/consumption: forecasted consumption in W
- /FCST/prices: forecasted price in EUR
- /FCST/net_consumption: forecasted net consumption in W

Implemented Input-API:
- /mode/set: set mode (-1 = charge from grid, 0 = avoid discharge, 10 = discharge allowed)
- /charge_rate/set: set charge rate in W, sets mode to -1
- /always_allow_discharge_limit/set: set always discharge limit in 0.1-1
- /max_charging_from_grid_limit/set: set charge limit in 0-1
- /min_price_difference/set: set minimum price difference in EUR

The module uses the paho-mqtt library for MQTT communication and numpy for handling arrays.
"""
import time
import json
import logging
import paho.mqtt.client as mqtt
import numpy as np

logger = logging.getLogger('__main__')
logger.info('[MQTT] loading module ')

class MqttApi:
    """ MQTT API to publish data from batcontrol to MQTT for further processing+visualization"""
    SET_SUFFIX = '/set'
    def __init__(self, config:dict):
        self.config=config
        self.base_topic = config['topic']
        if config.get('auto_discover_enable'):
            self.auto_discover_enable = config['auto_discover_enable']
        else:
            self.auto_discover_enable = False

        if config.get('auto_discover_topic'):
            self.auto_discover_topic = config['auto_discover_topic']
        else:
            self.auto_discover_topic = "homeassistant"

        self.callbacks = {}

        self.client = mqtt.Client()
        if 'logger' in config and config['logger'] is True:
            self.client.enable_logger(logger)

        if 'username' in config and 'password' in config:
            self.client.username_pw_set(config['username'], config['password'])

        self.client.will_set(self.base_topic + '/status', 'offline', retain=True)

        # TLS , not tested yet
        if config['tls'] is True:
            self.client.tls_set(
                config['tls']['ca_certs'],
                config['tls']['certfile'],
                config['tls']['keyfile'],
                cert_reqs=config['tls']['cert_reqs'],
                tls_version=config['tls']['tls_version'],
                ciphers=config['tls']['ciphers']
            )

        self.client.on_connect = self.on_connect
        self.client.loop_start()
        retry_attempts = config.get('retry_attempts', 5)
        retry_delay = config.get('retry_delay', 10)
        while retry_attempts > 0:
            try:
                self.client.connect(config['broker'], config['port'], 60)
                break
            except (ValueError, TypeError) as e:
                logger.error('[MQTT] Connection failed: %s, retrying[%d]x in [%d] seconds',
                                e, retry_attempts, retry_delay)
                retry_attempts -= 1
                if retry_attempts == 0:
                    logger.error('[MQTT] All retry attempts failed')
                    raise
                logger.info('[MQTT] Retrying connection in %d seconds...', retry_delay)
                time.sleep(retry_delay)

    def on_connect(self, client, userdata, flags, rc):
        """ Callback for MQTT connection to serve /status"""
        logger.info('[MQTT] Connected with result code %s', rc)
        # Make public, that we are running.
        client.publish(self.base_topic + '/status', 'online', retain=True)
        # publish HA mqtt AutoDiscovery messages at startup
        if self.auto_discover_enable:
            self.send_mqtt_discovery_messages()
        # Handle reconnect case
        for topic in self.callbacks:
            logger.debug('[MQTT] Subscribing topic: %s', topic)
            for topic in self.callbacks:
                client.subscribe(topic)

    def wait_ready(self) -> bool:
        """ Wait for MQTT connection to be ready"""
        retry = 30
        # Check if we are connected and wait for it
        while self.client.is_connected() is False:
            retry -= 1
            if retry == 0:
                logger.error('[MQTT] Could not connect to MQTT Broker')
                return False
            logger.info('[MQTT] Waiting for connection')
            time.sleep(1)

        return True

    def _handle_message(self, client, userdata, message):  # pylint: disable=unused-argument
        """ Handle and dispatch incoming messages"""
        logger.debug('[MQTT] Received message on %s', message.topic)
        if message.topic in self.callbacks:
            try:
                self.callbacks[message.topic]['function'](
                    self.callbacks[message.topic]['convert'](message.payload)
                )
            except (ValueError, TypeError) as e:
                logger.error('[MQTT] Error in callback %s : %s', message.topic, e)
        else:
            logger.warning('[MQTT] No callback registered for %s', message.topic)

    def register_set_callback(self, topic:str,  callback:callable, convert: callable) -> None:
        """ Generic- register a callback for changing values inside batcontrol via
            MQTT set topics
        """
        topic_string = self.base_topic + "/" + topic + MqttApi.SET_SUFFIX
        logger.debug('[MQTT] Registering callback for %s', topic_string)
                # set api endpoints, generic subscription
        self.callbacks[topic_string] = { 'function' : callback , 'convert' : convert }
        self.client.subscribe(topic_string)
        self.client.message_callback_add(topic_string , self._handle_message)

    def publish_mode(self, mode:int) -> None:
        """ Publish the mode (charge, lock, discharge) to MQTT
            /mode
        """
        if self.client.is_connected():
            self.client.publish(self.base_topic + '/mode', mode)

    def publish_charge_rate(self, rate:float) -> None:
        """ Publish the forced charge rate in W to MQTT
            /charge_rate
        """
        if self.client.is_connected():
            self.client.publish(self.base_topic + '/charge_rate', rate)

    def publish_production(self, production:np.ndarray, timestamp:float) -> None:
        """ Publish the production to MQTT
            /FCST/production
            The value is in W and based of solar forecast API.
            The length is the same as used in internal arrays.
        """
        if self.client.is_connected():
            self.client.publish(
                self.base_topic + '/FCST/production',
                json.dumps(self._create_forecast(production, timestamp))
            )

    def _create_forecast(self, forecast:np.ndarray, timestamp:float) -> dict:
        """ Create a forecast JSON object
            from a numpy array and a timestamp
        """
        # Take timestamp and reduce it to the first second of the hour
        now = timestamp - (timestamp % 3600)

        data_list = []
        for h, value in enumerate(forecast):
            # next hour after now
            data_list.append(
            {
                'time_start': now + h * 3600,
                'value': value,
                'time_end': now - h + (h + 1) * 3600
            }
            )

        data = { 'data' : data_list }
        return data


    def publish_consumption(self, consumption:np.ndarray, timestamp:float) -> None:
        """ Publish the consumption to MQTT
            /FCST/consumption
            The value is in W and based of load profile and multiplied with
                personal yearly consumption.
            The length is the same as used in internal arrays.
        """
        if self.client.is_connected():
            self.client.publish(
                self.base_topic + '/FCST/consumption',
                json.dumps(self._create_forecast(consumption,timestamp))
            )

    def publish_prices(self, price:np.ndarray ,timestamp:float) -> None:
        """ Publish the prices to MQTT
            /FCST/prices
            The length is the same as used in internal arrays.
        """
        if self.client.is_connected():
            self.client.publish(
                self.base_topic + '/FCST/prices',
                json.dumps(self._create_forecast(price,timestamp))
            )

    def publish_net_consumption(self, net_consumption:np.ndarray, timestamp:float) -> None:
        """ Publish the net consumption in W to MQTT
            /FCST/net_consumption
            The length is the same as used in internal arrays.
            This is the difference between production and consumption.
        """
        if self.client.is_connected():
            self.client.publish(
                self.base_topic + '/FCST/net_consumption',
                json.dumps(self._create_forecast(net_consumption,timestamp))
            )

    def publish_SOC(self, soc:float) -> None:       # pylint: disable=invalid-name
        """ Publish the state of charge in % to MQTT
            /SOC
        """
        if self.client.is_connected():
            self.client.publish(self.base_topic + '/SOC', f'{int(soc):03}')

    def publish_stored_energy_capacity(self, stored_energy:float) -> None:
        """ Publish the stored energy capacity in Wh to MQTT
            /stored_energy_capacity
        """
        if self.client.is_connected():
            self.client.publish(
                self.base_topic + '/stored_energy_capacity',
                f'{stored_energy:.1f}')

    def publish_stored_usable_energy_capacity(self, stored_energy:float) -> None:
        """ Publish the stored usable energy capacity in Wh to MQTT
            /stored_usable_energy_capacity
        """
        if self.client.is_connected():
            self.client.publish(
                self.base_topic + '/stored_usable_energy_capacity',
                f'{stored_energy:.1f}'
            )

    def publish_reserved_energy_capacity(self, reserved_energy:float) -> None:
        """ Publish the reserved energy capacity in Wh to MQTT
            /reserved_energy_capacity
        """
        if self.client.is_connected():
            self.client.publish(
                self.base_topic + '/reserved_energy_capacity',
                f'{reserved_energy:.1f}'
            )

    def publish_always_allow_discharge_limit_capacity(self, discharge_limit:float) -> None:
        """ Publish the always discharge limit in Wh to MQTT
            /always_allow_discharge_limit_capacity
        """
        if self.client.is_connected():
            self.client.publish(
                self.base_topic + '/always_allow_discharge_limit_capacity',
                f'{discharge_limit:.1f}'
            )

    def publish_always_allow_discharge_limit(self, allow_discharge_limit:float) -> None:
        """ Publish the always discharge limit to MQTT
            /always_allow_discharge_limit as digit
            /always_allow_discharge_limit_percent
        """
        if self.client.is_connected():
            self.client.publish(
                self.base_topic + '/always_allow_discharge_limit',
                f'{allow_discharge_limit:.2f}'
            )
            self.client.publish(
                self.base_topic + '/always_allow_discharge_limit_percent',
                f'{allow_discharge_limit * 100:.0f}'
            )

    def publish_max_charging_from_grid_limit(self, charge_limit:float) -> None:
        """ Publish the maximum charging limit to MQTT
            /max_charging_from_grid_limit_percent
            /max_charging_from_grid_limit   as digit.
        """
        if self.client.is_connected():
            self.client.publish(
                self.base_topic + '/max_charging_from_grid_limit_percent',
                f'{charge_limit * 100:.0f}'
            )
            self.client.publish(
                self.base_topic + '/max_charging_from_grid_limit',
                f'{charge_limit:.2f}'
            )

    def publish_min_price_difference(self, min_price_difference:float) -> None:
        """ Publish the minimum price difference to MQTT found in config
            /min_price_difference
        """
        if self.client.is_connected():
            self.client.publish(
                self.base_topic + '/min_price_difference',
                f'{min_price_difference:.3f}'
            )

    def publish_min_price_difference_rel(self, min_price_difference_rel:float) -> None:
        """ Publish the relative minimum price difference to MQTT found in config
            /min_price_difference_rel
        """
        if self.client.is_connected():
            self.client.publish(
                self.base_topic + '/min_price_difference_rel',
                f'{min_price_difference_rel:.3f}'
            )

    def publish_min_dynamic_price_diff(self, dynamic_price_diff:float) -> None:
        """ Publish the dynamic price difference limit to MQTT
            /min_dynamic_price_difference
        """
        if self.client.is_connected():
            self.client.publish(
                self.base_topic + '/min_dynamic_price_difference',
                f'{dynamic_price_diff:.3f}'
            )

    def publish_max_energy_capacity(self, max_capacity:float) -> None:
        """ Publish the maximum energy capacity to MQTT
            /max_energy_capacity
        """
        if self.client.is_connected():
            self.client.publish(
                self.base_topic + '/max_energy_capacity',
                f'{max_capacity:.1f}'
            )

    def publish_evaluation_intervall(self, intervall:int) -> None:
        """ Publish the evaluation intervall to MQTT
            /evaluation_intervall
        """
        if self.client.is_connected():
            self.client.publish(self.base_topic + '/evaluation_intervall', f'{intervall:.0f}')

    def publish_last_evaluation_time(self, timestamp:float) -> None:
        """ Publish the last evaluation timestamp to MQTT
            This is the time when the last evaluation was started.
            /last_evaluation
        """
        if self.client.is_connected():
            self.client.publish(self.base_topic + '/last_evaluation', f'{timestamp:.0f}')

    def publish_discharge_blocked(self, discharge_blocked:bool) -> None:
        """ Publish the discharge blocked status to MQTT
            /discharge_blocked
        """
        if self.client.is_connected():
            self.client.publish(self.base_topic + '/discharge_blocked', str(discharge_blocked))

    # For depended APIs like the Fronius Inverter classes, which is not directly batcontrol.
    def generic_publish(self, topic:str, value:str) -> None:
        """ Publish a generic value to a topic
            For depended APIs like the Fronius Inverter classes, which is not directly batcontrol.
        """
        if self.client.is_connected():
            self.client.publish(self.base_topic + '/' + topic, value)

    # mqtt auto discovery
    def send_mqtt_discovery_messages(self) -> None:
        """ Publish all offered mqtt discovery config messages
        """
        # control
        self.send_mqtt_discovery_for_mode()
        # sensors
        self.publish_mqtt_discovery_message("SOC Inverter 0",
            "batcontrol_inverter_0_SOC",
            "sensor", "battery", "%",
            self.base_topic + "/inverters/0/SOC")
        self.publish_mqtt_discovery_message("Discharge Blocked",
            "batcontrol_discharge_blocked",
            "sensor", None, None,
            self.base_topic + "/discharge_blocked",
            value_template="{% if value | lower == 'True' %}blocked{% else %}not blocked{% endif %}"
            )
        self.publish_mqtt_discovery_message("Reserved Energy Capacity",
            "batcontrol_reserved_energy_capacity", "sensor", "energy", "Wh",
            self.base_topic + "/reserved_energy_capacity")
        self.publish_mqtt_discovery_message("Stored Usable Energy Capacity",
            "batcontrol_stored_usable_energy_capacity", "sensor", "energy", "Wh",
            self.base_topic + "/stored_usable_energy_capacity")
        self.publish_mqtt_discovery_message("Min Price Difference Relative",
            "batcontrol_min_price_difference_rel", "sensor", "monetary", None,
            self.base_topic + "/min_price_difference_rel")
        self.publish_mqtt_discovery_message("Min Dynamic Price Difference",
            "batcontrol_min_dynamic_price_difference", "sensor", "monetary", None,
            self.base_topic + "/min_dynamic_price_difference")
        # configuration
        self.publish_mqtt_discovery_message("Charge Rate",
            "batcontrol_charge_rate", "number", "power", "W", 
            self.base_topic + "/charge_rate",
            self.base_topic + "/charge_rate/set",
            entity_category="config",
            min_value=0,
            max_value=10000,
            initial_value=10000)
        self.publish_mqtt_discovery_message("Max Grid Charge Rate",
            "batcontrol_max_grid_charge_rate", "number", "power", "W",
            self.base_topic + "/inverters/0/max_grid_charge_rate",
            self.base_topic + "/inverters/0/max_grid_charge_rate/set",
            entity_category="config",min_value=0, max_value=10000,initial_value=10000)
        self.publish_mqtt_discovery_message("Max PV Charge Rate",
            "batcontrol_max_pv_charge_rate", "number", "power", "W",
            self.base_topic + "/inverters/0/max_pv_charge_rate",
            self.base_topic + "/inverters/0/max_pv_charge_rate/set",
            entity_category="config",min_value=0, max_value=10000,initial_value=10000)
        # prepared for other PR regarding /fix_discharge_with_max_power_set
        #self.publish_mqtt_discovery_message("Max Bat Discharge Rate",
        #   "batcontrol_max_bat_discharge_rate", "number", "power", "W",
        #   self.base_topic + "/inverters/0/max_bat_discharge_rate",
        #   self.base_topic + "/inverters/0/max_bat_discharge_rate/set",entity_category="config",
        #   min_value=0, max_value=10000,initial_value=10000)
        self.publish_mqtt_discovery_message("Always Allow Discharge Limit",
            "batcontrol_always_allow_discharge_limit", "number", None, None,
            self.base_topic + "/always_allow_discharge_limit",
            self.base_topic + "/always_allow_discharge_limit/set",
            entity_category="config",
            min_value=0.0, max_value=1.0, step_value=0.1, initial_value=0.9)
        self.publish_mqtt_discovery_message("Max Charging From Grid Limit",
            "batcontrol_max_charging_from_grid_limit", "number", None, None,
            self.base_topic + "/max_charging_from_grid_limit",
            self.base_topic + "/max_charging_from_grid_limit/set",
            entity_category="config",
            min_value=0.0, max_value=1.0, step_value=0.1, initial_value=0.9)
        self.publish_mqtt_discovery_message("Min Price Difference",
            "batcontrol_min_price_difference", "number", "monetary", None,
            self.base_topic + "/min_price_difference",
            self.base_topic + "/min_price_difference/set",
            entity_category="config",
            min_value=0, max_value=0.5, step_value=0.01, initial_value=0.05)
        # diagnostic
        self.publish_mqtt_discovery_message("Status",
            "batcontrol_status", "sensor", None, None,
            self.base_topic + "/status", command_topic=None, entity_category="diagnostic")
        self.publish_mqtt_discovery_message("Last Evaluation",
            "batcontrol_last_evaluation", "sensor", "timestamp", None,
            self.base_topic + "/last_evaluation", command_topic=None, entity_category="diagnostic",
            options=None,
            value_template="{{ (value | int | timestamp_local) }}",command_template=None)
        self.publish_mqtt_discovery_message("SOC Main",
            "batcontrol_soc", "sensor", "battery", "%",
            self.base_topic + "/SOC", entity_category="diagnostic")
        self.publish_mqtt_discovery_message("Max Energy Capacity",
            "batcontrol_max_energy_capacity", "sensor", "energy", "Wh",
            self.base_topic + "/max_energy_capacity", entity_category="diagnostic")
        self.publish_mqtt_discovery_message("Always Allow Discharge Limit Capacity",
            "batcontrol_always_allow_discharge_limit_capacity", "sensor", "energy", "Wh",
            self.base_topic + "/always_allow_discharge_limit_capacity",
            entity_category="diagnostic")
        self.publish_mqtt_discovery_message("Stored Energy Capacity",
            "batcontrol_stored_energy_capacity", "sensor", "energy", "Wh",
            self.base_topic + "/stored_energy_capacity", entity_category="diagnostic")

    def send_mqtt_discovery_for_mode(self) -> None:
        """ Publish Home Assistant MQTT Auto Discovery message for mode"""
        val_templ = (
                    "{% if value == '-1' %}Charge from Grid"
                    "{% elif value == '0' %}Avoid Discharge"
                    "{% elif value == '10' %}Discharge Allowed"
                    "{% else %}Unknown"
                    "{% endif %}"
        )
        cmd_templ = (
                    "{% if value == 'Charge from Grid' %}-1"
                    "{% elif value == 'Avoid Discharge' %}0"
                    "{% elif value == 'Discharge Allowed' %}10"
                    "{% else %}-1"
                    "{% endif %}"
        )
        self.publish_mqtt_discovery_message(
            "Batcontrol mode", "batcontrol_mode", "select", None, None, 
            self.base_topic + "/mode",
            self.base_topic + "/mode/set", entity_category=None,
            options=["Charge from Grid", "Avoid Discharge", "Discharge Allowed"],
            value_template=val_templ, command_template=cmd_templ)

    # Home Assistant MQTT Auto Discovery
    # https://www.home-assistant.io/docs/mqtt/discovery/
    # item_type = sensor, switch, binary_sensor, select
    # device_class = battery, power, energy, temperature, humidity,
    #                   timestamp, signal_strength, problem, connectivity
    def publish_mqtt_discovery_message(self, name:str, unique_id:str,
        item_type:str, device_class:str, unit_of_measurement:str,
        state_topic:str, command_topic:str=None, entity_category:str=None,
        min_value=None, max_value=None, step_value=None, initial_value=None,
        options:str=None, value_template:str=None, command_template:str=None
        ) -> None:
        """ Publish Home Assistant MQTT Auto Discovery message"""
        if self.client.is_connected():
            payload = {}
            payload["name"] = name
            payload["unique_id"] = unique_id
            payload["state_topic"] = state_topic
            if value_template:
                payload["value_template"] = value_template
            if command_topic:
                payload["command_topic"] = command_topic
            if command_template:
                payload["command_template"] = command_template
            if device_class:
                payload["device_class"] = device_class
            if unit_of_measurement:
                payload["unit_of_measurement"] = unit_of_measurement
            if item_type == "number":
                payload["min"] = min_value
                payload["max"] = max_value
                if step_value:
                    payload["step"] = step_value
                payload["mode"] = "box"
            if entity_category:
                payload["entity_category"] = entity_category
            if initial_value:
                payload["initial"] = initial_value
            if options:
                payload["options"] = options
            device = {
                "identifiers": "Batcontrol",
                "name": "Batcontrol",
                "manufacturer": "muexxl",
                "model": "batcontrol",
                "sw_version": "0.3.x"
            }
            payload["device"] = device
            logger.debug(
                '[MQTT] sending HA AD config message for %s',
                self.auto_discover_topic + '/' + item_type + '/' + unique_id + '/config')
            self.client.publish(
                self.auto_discover_topic + '/' + item_type + '/batcontrol/' + unique_id + '/config',
                json.dumps(payload), retain=True)

================
File: __init__.py
================
from .__pkginfo__ import __version__

================
File: __main__.py
================
from .core import Batcontrol
import time
import datetime
import sys

CONFIGFILE = "config/batcontrol_config.yaml"
EVALUATIONS_EVERY_MINUTES = 3  # Every x minutes on the clock

def main() -> int:
    bc = Batcontrol(CONFIGFILE)
    try:
        while True:
            bc.run()
            loop_now = datetime.datetime.now().astimezone(bc.timezone)
            # reset base to full minutes on the clock
            next_eval = loop_now - datetime.timedelta(
                minutes=loop_now.minute % EVALUATIONS_EVERY_MINUTES,
                seconds=loop_now.second,
                microseconds=loop_now.microsecond
            )
            # add time increments to trigger next evaluation
            next_eval += datetime.timedelta(minutes=EVALUATIONS_EVERY_MINUTES)
            sleeptime = (next_eval - loop_now).total_seconds()
            print(f"Next evaluation at {next_eval.strftime('%H:%M:%S')}. Sleeping for {sleeptime:.0f} seconds")
            time.sleep(sleeptime)
    except KeyboardInterrupt:
        print("Shutting down")
    finally:
        bc.shutdown()
        del bc
    return 0

if __name__ == "__main__":
    sys.exit(main())

================
File: __pkginfo__.py
================
__version__ = '0.5.0dev'

================
File: dynamictariff\awattar.py
================
"""Awattar Class

This module implements the Awattar API to retrieve dynamic electricity prices.
It inherits from the DynamicTariffBaseclass.

Classes:
    Awattar: A class to interact with the Awattar API and process electricity prices.

Methods:
    __init__(self,
                timezone, country: str,
                price_fees: float,
                price_markup: float,
                vat: float,
                min_time_between_API_calls=0):

        Initializes the Awattar class with the specified parameters.

    get_raw_data_from_provider(self):
        Fetches raw data from the Awattar API.

    get_prices_from_raw_data(self):
        Processes the raw data to extract and calculate electricity prices.
"""
import datetime
import math
import requests
from .baseclass import DynamicTariffBaseclass

class Awattar(DynamicTariffBaseclass):
    """ Implement Awattar API to get dynamic electricity prices
        Inherits from DynamicTariffBaseclass
    """

    def __init__(self, timezone ,country:str, min_time_between_API_calls=0, delay_evaluation_by_seconds=0):
        super().__init__(timezone,min_time_between_API_calls, delay_evaluation_by_seconds)
        country= country.lower()
        if country in ['at','de']:
            self.url=f'https://api.awattar.{country}/v1/marketdata'
        else:
            raise RuntimeError(f'[Awattar] Country Code {country} not known')

        self.vat=0
        self.price_fees=0
        self.price_markup=0

    def set_price_parameters(self, vat:float, price_fees:float, price_markup:float):
        """ Set the extra price parameters for the tariff calculation """
        self.vat=vat
        self.price_fees=price_fees
        self.price_markup=price_markup

    def get_raw_data_from_provider(self):
        response=requests.get(self.url, timeout=30)
        if response.status_code != 200:
            raise RuntimeError(f'[Awattar_AT] API returned {response}')

        raw_data=response.json()
        return raw_data


    def get_prices_from_raw_data(self):
        data=self.raw_data['data']
        now=datetime.datetime.now().astimezone(self.timezone)
        prices={}
        for item in data:
            timestamp=datetime.datetime.fromtimestamp(
                            item['start_timestamp']/1000).astimezone(self.timezone
                        )
            diff=timestamp-now
            rel_hour=math.ceil(diff.total_seconds()/3600)
            if rel_hour >=0:
                end_price=( item['marketprice']/1000*(1+self.price_markup) + self.price_fees
                          ) * (1+self.vat)
                prices[rel_hour]=end_price
        return prices

================
File: dynamictariff\baseclass.py
================
""" Parent Class for implementing different tariffs"""
import time
import random
import logging
from .dynamictariff_interface import TariffInterface


logger = logging.getLogger('__main__')

class DynamicTariffBaseclass(TariffInterface):
    """ Parent Class for implementing different tariffs"""
    def __init__(self, timezone,min_time_between_API_calls, delay_evaluation_by_seconds) -> None:  #pylint: disable=invalid-name
        self.raw_data={}
        self.last_update=0
        self.min_time_between_updates=min_time_between_API_calls
        self.timezone=timezone
        self.delay_evaluation_by_seconds=delay_evaluation_by_seconds

    def get_prices(self) -> dict[int, float]:
        """ Get prices from provider """
        now=time.time()
        time_passed=now-self.last_update
        if time_passed> self.min_time_between_updates:
            # Not on initial call
            if self.last_update > 0 and self.delay_evaluation_by_seconds > 0:
                sleeptime = random.randrange(0, self.delay_evaluation_by_seconds, 1)
                logger.debug(
                        '[Tariff] Waiting for %d seconds before requesting new data',
                        sleeptime)
                time.sleep(sleeptime)
            self.raw_data=self.get_raw_data_from_provider()
            self.last_update=now
        prices=self.get_prices_from_raw_data()
        return prices

    def get_raw_data_from_provider(self) -> dict:
        """ Prototype for get_raw_data_from_provider """
        raise RuntimeError("[Dyn Tariff Base Class] Function "
                           "'get_raw_data_from_provider' not implemented"
                           )

    def get_prices_from_raw_data(self) -> dict[int, float]:
        """ Prototype for get_prices_from_raw_data """
        raise RuntimeError("[Dyn Tariff Base Class] Function "
                           "'get_prices_from_raw_data' not implemented"
                           )

================
File: dynamictariff\dynamictariff.py
================
"""
DynamicTariff class to select and configure a dynamic tariff provider based
     on the given configuration.

Args:
    config (dict): Configuration dictionary containing the provider type and necessary parameters.
    timezone (str): Timezone information.
    min_time_between_API_calls (int): Minimum time interval between API calls.

Returns:
    selected_tariff: An instance of the selected tariff provider class (Awattar, Tibber, or Evcc).

Raises:
    RuntimeError: If required fields are missing in the configuration
                     or if the provider type is unknown.
"""
from .awattar import Awattar
from .tibber import Tibber
from .evcc import Evcc
from .dynamictariff_interface import TariffInterface

class DynamicTariff:
    """ DynamicTariff factory"""
    @staticmethod
    def create_tarif_provider(config:dict, timezone,
                              min_time_between_api_calls,
                              delay_evaluation_by_seconds
                              ) -> TariffInterface:
        """ Select and configure a dynamic tariff provider based on the given configuration """
        selected_tariff=None
        provider=config['type']

        if provider.lower()=='awattar_at':
            required_fields=['vat', 'markup', 'fees']
            for field in required_fields:
                if not field in config.keys():
                    raise RuntimeError(
                        f'[DynTariff] Please include {field} in your configuration file'
                    )
            vat = float(config['vat'])
            markup = float(config['markup'])
            fees = float(config['fees'])
            selected_tariff= Awattar(timezone,'at',
                                     min_time_between_api_calls,
                                     delay_evaluation_by_seconds
                                    )
            selected_tariff.set_price_parameters(vat,fees,markup)

        elif provider.lower()=='awattar_de':
            required_fields=['vat', 'markup', 'fees']
            for field in required_fields:
                if not field in config.keys():
                    raise RuntimeError(
                        f'[DynTariff] Please include {field} in your configuration file'
                    )
            vat = float(config['vat'])
            markup = float(config['markup'])
            fees = float(config['fees'])
            selected_tariff= Awattar(timezone,'de',
                                     min_time_between_api_calls,
                                     delay_evaluation_by_seconds
                                     )
            selected_tariff.set_price_parameters(vat,fees,markup)

        elif provider.lower()=='tibber':
            if not 'apikey' in config.keys() :
                raise RuntimeError (
                    '[Dynamic Tariff] Tibber requires an API token. '
                    'Please provide "apikey :YOURKEY" in your configuration file'
                    )
            token = config['apikey']
            selected_tariff=Tibber(timezone,
                                   token,
                                   min_time_between_api_calls,
                                   delay_evaluation_by_seconds
                                   )

        elif provider.lower()=='evcc':
            if not 'url' in config.keys() :
                raise RuntimeError (
                    '[Dynamic Tariff] evcc requires an URL. '
                    'Please provide "url" in your configuration file, '
                    'like http://evcc.local/api/tariff/grid'
                    )
            selected_tariff= Evcc(timezone,config['url'],min_time_between_api_calls)
        else:
            raise RuntimeError(f'[DynamicTariff] Unkown provider {provider}')
        return selected_tariff

================
File: dynamictariff\dynamictariff_interface.py
================
""" Interface for tariff classes """

from abc import ABC, abstractmethod

class TariffInterface(ABC):
    """ Interface for tariff classes """
    @abstractmethod
    def __init__(self, timezone, min_time_between_api_calls, delay_evaluation_by_seconds):
        """ Initialize the tariff class """

    @abstractmethod
    def get_prices(self) -> dict[int, float]:
        """ get prices in processable format with hours as keys """

================
File: dynamictariff\evcc.py
================
"""
This module defines the Evcc class, which is used to interact with the evcc API to fetch
dynamic tariff data.

Classes:
    Evcc: A class to interact with the evcc API and process dynamic tariff data.

Methods:
    __init__(self, timezone, url, min_time_between_API_calls=60):
        Initializes the Evcc instance with the given timezone, API URL,
        and minimum time between API calls.

    get_raw_data_from_provider(self):
        Fetches raw data from the evcc API and returns it as a JSON object.

    get_prices_from_raw_data(self):
        Processes the raw data from the evcc API and returns a dictionary of prices
        indexed by the relative hour.

    test():
        A test function to run the Evcc class with a provided URL and print the fetched prices.

Usage:
    To use this module, run it as a script with the API URL as an argument:
    python evcc.py <url>
"""
import datetime
import math
import requests
from .baseclass import DynamicTariffBaseclass

class Evcc(DynamicTariffBaseclass):
    """ Implement evcc API to get dynamic electricity prices
        Inherits from DynamicTariffBaseclass
    """
    def __init__(self, timezone , url , min_time_between_API_calls=60):
        super().__init__(timezone,min_time_between_API_calls, 0)
        self.delay_evaluation_by_seconds=0
        self.url=url

    def get_raw_data_from_provider(self) -> dict:  # pylint: disable=unused-private-member
        response=requests.get(self.url, timeout=30)

        if response.status_code != 200:
            raise RuntimeError(f'[evcc] API returned {response}')

        # {"result":
        #     { "rates": [
        #            {
        #                "start":"2024-06-20T08:00:00+02:00",
        #                "end":"2024-06-20T09:00:00+02:00",
        #                "price":0.35188299999999995
        #             },
        #            {
        #               "start":"2024-06-20T09:00:00+02:00",
        #                "end":"2024-06-20T10:00:00+02:00",
        #                "price":0.3253459999999999"
        #            }
        #        ]
        #     }
        # }

        raw_data=response.json()
        return raw_data


    def get_prices_from_raw_data(self) -> dict[int, float]:   # pylint: disable=unused-private-member
        data=self.raw_data['result']['rates']
        now=datetime.datetime.now().astimezone(self.timezone)
        prices={}

        for item in data:
            # "start":"2024-06-20T08:00:00+02:00" to timestamp
            timestamp=datetime.datetime.fromisoformat(item['start']).astimezone(self.timezone)
            diff=timestamp-now
            rel_hour=math.ceil(diff.total_seconds()/3600)
            if rel_hour >=0:
                prices[rel_hour]=item['price']
        return prices

def test():
    """
    This script tests the functionality of the Evcc class by fetching and printing
    electric vehicle charging prices from a specified URL.

    Usage:
        python evcc.py <url>

    Arguments:
        url (str): The URL to fetch the EV charging prices from.

    The script performs the following steps:
    1. Initializes an instance of the Evcc class with the specified URL and the
       'Europe/Berlin' timezone.
    2. Fetches the EV charging prices using the get_prices method of the Evcc class.
    3. Prints the fetched prices in a formatted JSON structure.

    Dependencies:
        - sys
        - json
        - pytz
    """
    import sys  # pylint: disable=import-outside-toplevel
    import json # pylint: disable=import-outside-toplevel
    import pytz # pylint: disable=import-outside-toplevel
    if len(sys.argv) != 2:
        print("Usage: python evcc.py <url>")
        sys.exit(1)

    url = sys.argv[1]
    evcc = Evcc(pytz.timezone('Europe/Berlin'), url)  # Assuming the Evcc constructor takes a URL

    prices = evcc.get_prices()
    print(json.dumps(prices, indent=4))

if __name__ == "__main__":
    test()

================
File: dynamictariff\tibber.py
================
""" Implement Tibber API to get dynamic electricity prices
"""

import datetime
import math
import requests
from .baseclass import DynamicTariffBaseclass

class Tibber(DynamicTariffBaseclass):
    """ Implement Tibber API to get dynamic electricity prices
        Inherits from DynamicTariffBaseclass
    """
    def __init__(self, timezone , token, min_time_between_API_calls=0, delay_evaluation_by_seconds=0):
        super().__init__(timezone,min_time_between_API_calls, delay_evaluation_by_seconds)
        self.access_token=token
        self.url="https://api.tibber.com/v1-beta/gql"

    def get_raw_data_from_provider(self) -> dict:
        """ Get raw data from Tibber API """
        if not self.access_token:
            raise RuntimeError
        headers={"Authorization":"Bearer " + self.access_token,
                "Content-Type":"application/json"}
        data="""{ "query":
        "{viewer {homes {currentSubscription {priceInfo { current {total startsAt } today {total startsAt } tomorrow {total startsAt }}}}}}" }
        """
        response=requests.post(self.url, data, headers=headers, timeout=30)
        if response.status_code != 200:
            raise RuntimeError(f'[Tibber] Tibber Api responded with Error {response}')
        raw_data=response.json()
        return raw_data


    def get_prices_from_raw_data(self) -> dict[int, float]:
        """ Extract prices from raw to internal datastracture based on hours """
        homeid=0
        rawdata=self.raw_data['data']
        now=datetime.datetime.now().astimezone(self.timezone)
        prices={}
        for day in ['today', 'tomorrow']:
            dayinfo=rawdata['viewer']['homes'][homeid]['currentSubscription']['priceInfo'][day]
            for item in dayinfo:
                timestamp=datetime.datetime.fromisoformat(item['startsAt'])
                diff=timestamp-now
                rel_hour=math.ceil(diff.total_seconds()/3600)
                if rel_hour >=0:
                    prices[rel_hour]=item['total']
        return prices

================
File: dynamictariff\__init__.py
================
from .dynamictariff import DynamicTariff

================
File: forecastconsumption\consumption.py
================
""" Factory for creating consumption forecasters. """
import logging
from .forecastconsumption_interface import ForecastConsumptionInterface
from .forecast_csv import ForecastConsumptionCsv

logger = logging.getLogger('__main__').getChild('ConsumptionFactory')
logger.info('[Consumption] loading module ')

DEFAULT_CSV_FILE = 'default_load_profile.csv'

class Consumption:
    """ Factory for consumption forecast providers """

    @staticmethod
    def create_consumption(tz, config: dict) -> ForecastConsumptionInterface:
        """ Select and configure a consumption forecast provider based on
            the given configuration segment consumption_forecast in the config file."""
        consumption = None

        # csv is the default.
        if config.get('type', 'csv').lower() == 'csv':
            csv_config = {}
            if 'csv' in config:
                csv_config = config['csv']
            else:
                # Backwards compatibility
                csv_config['annual_consumption'] = config.get('annual_consumption', 0)
                csv_config['load_profile'] = config.get('load_profile', None)

            if csv_config.get('load_profile', None) is None:
                logger.error(
                    "[Consumption] No load profile specified, using default: %s",
                    DEFAULT_CSV_FILE
                )
                csv_config['load_profile'] = DEFAULT_CSV_FILE

            consumption = ForecastConsumptionCsv(
                                'config/' + csv_config['load_profile'],
                                tz,
                                csv_config.get('annual_consumption', 0)
                            )

        return consumption

================
File: forecastconsumption\forecastconsumption_interface.py
================
""" Interface for consumption forecast classes """

from abc import ABC, abstractmethod

class ForecastConsumptionInterface(ABC):
    """ Interface for ConsumptionAPI classes """

    @abstractmethod
    def get_forecast(self, hours) -> dict[int, float]:
        """ Get consumption forecast up to next 48 hours """

================
File: forecastconsumption\forecast_csv.py
================
#%%
import datetime
import math
import logging
import pandas as pd
import numpy as np
import os
from .forecastconsumption_interface import ForecastConsumptionInterface


logger = logging.getLogger("__main__").getChild("FCConsumptionCSV")
logger.info('[FCConsumption] loading module')

class ForecastConsumptionCsv(ForecastConsumptionInterface):
    """Forecasts Consumption based on load profiles

        Loadprofile:
        csv file containing, month(1..12), weekday(0..6, 0-Monday), hour(0..24) and Energy in Wh

        Can create load profiles:
        required input: csv file containing
            - 'timestamp' Timestamp in ISO format
            - 'energy' consumption in one our periods measured in Ws - Yes, Wattseconds!

        forecasting will be done by considering month, weekday and hour
    """

    def __init__(self, loadprofile, timezone, annual_consumption=0 , datafile=None, ) -> None:
        if not os.path.isfile(loadprofile):
            raise RuntimeError(
                "[ForecastCSV] Specified Load Profile file " +
                f"'{loadprofile}' not found"
            )

        self.path_to_load_profile=loadprofile
        if datafile:
            self.create_loadprofile(datafile,self.path_to_load_profile)
        self.load_loadprofile()
        if annual_consumption >0:
            self.scaling_factor = self.calculate_scaling_factor(annual_consumption)
            logger.info(
                    "[FC Cons] the hourly values from the load profile are scaled with a "
                    "factor of %.2f to match the annual consumption of %d kWh",
                    self.scaling_factor,
                    annual_consumption
                    )
        else:
            self.scaling_factor=1
            annual_consumption_load_profile= self.dataframe['energy'].sum()*8760/2016/1000
            logger.info(
                "[FC Cons] The annual consumption of the applied load profile is %.2f kWh ",
                 annual_consumption_load_profile
                )
            logger.info(
                "[FC Cons] You can specify your estimated annual consumption in the config file "
                "under consumption_forecast:  annual_consumption "
                )
        self.timezone=timezone

    def calculate_scaling_factor(self, annual_consumption):
        annual_consumption_load_profile= self.dataframe['energy'].sum()*8760/2016/1000
        logger.info(
            "[FC Cons] The annual consumption of the applied load profile is %s kWh ",
            annual_consumption_load_profile
            )
        scaling_factor = annual_consumption/annual_consumption_load_profile
        return scaling_factor

    def load_data_file(self, datafile):
        df = pd.read_csv(datafile)
        df['timestamp'] = df['timestamp'].map(
            lambda timestamp: pd.to_datetime(timestamp).astimezone(self.timezone))
        df['month'] = df['timestamp'].map(lambda timestamp: timestamp.month)
        df['weekday'] = df['timestamp'].map(
            lambda timestamp: timestamp.dayofweek)
        df['hour'] = df['timestamp'].map(lambda timestamp: timestamp.hour)
        # convert Ws to Wh and adjust sign
        df['energy'] = df['energy']/3600*-1
        return df

    def get_forecast(self, hours):
        t0 = datetime.datetime.now().astimezone(self.timezone)
        df = self.dataframe
        prediction = {}

        for h in range(hours):
            delta_t = datetime.timedelta(hours=h)
            t1 = t0+delta_t
            energy = df.loc[df['hour'] == t1.hour].loc[df['month'] ==
                                    t1.month].loc[df['weekday'] == t1.weekday()]['energy'].median()
            if math.isnan(energy):
                energy = df['energy'].median()
            prediction[h]=energy*self.scaling_factor

        logger.debug(
                  '[FC Cons] predicting consumption: %s',
                   np.array(list(prediction.values())).round(1)
                )
        return prediction

    def create_loadprofile(self, datafile, path_to_profile='load_profile.csv'):
        df=self.load_data_file(datafile)
        a=[]
        energy=0
        for month in range(1,13):
            for day in range(7):
                for hour in range(24):
                    energy = df.loc[df['hour'] == hour].loc[df['month'] == month].loc[df['weekday'] == day]['energy'].mean()  # pylint: disable=c0301
                    a.append([month,day,hour,energy])
        df_load_profile=pd.DataFrame(a)
        df_load_profile.to_csv(
                  path_to_profile,header=['month','weekday','hour','energy'],
                  index=None
                )

    def load_loadprofile(self):
        self.dataframe=pd.read_csv(self.path_to_load_profile)

================
File: forecastconsumption\__init__.py
================
from .consumption import Consumption

================
File: forecastsolar\fcsolar.py
================
""" Module to get forecast from Forecast Solar API

See https://forecast.solar/ for more information

"""

import datetime
import random
import time
import math
import json
import logging
import requests
from .forecastsolar_interface import ForecastSolarInterface

logger = logging.getLogger('__main__')
logger.info('[FCSolar] loading module')

class FCSolar(ForecastSolarInterface):
    """ Provider to get data from https://forecast.solar/ """
    def __init__(self, pvinstallations, timezone,
                 delay_evaluation_by_seconds) -> None:
        self.pvinstallations = pvinstallations
        self.results = {}
        self.last_update = 0
        self.seconds_between_updates = 900
        self.timezone=timezone
        self.rate_limit_blackout_window = 0
        self.delay_evaluation_by_seconds=delay_evaluation_by_seconds

    def get_forecast(self) -> dict:
        """ Get hourly forecast from provider """
        got_error = False
        t0 = time.time()
        dt = t0-self.last_update
        if dt > self.seconds_between_updates:
            if self.rate_limit_blackout_window < t0:
                try:
                    if self.last_update > 0 and self.delay_evaluation_by_seconds > 0:
                        sleeptime = random.randrange(0, self.delay_evaluation_by_seconds, 1)
                        logger.debug(
                            '[FCSolar] Waiting for %d seconds before requesting new data',
                            sleeptime)
                        time.sleep(sleeptime)
                    self.__get_raw_forecast()
                    self.last_update = t0
                except Exception as e:
                    # Catch error here.
                    # Check cached values below
                    logger.error('[FCSolar] Error getting forecast: %s', e)
                    logger.warning('[FCSolar] Using cached values')
                    got_error = True
            else:
                remaining_time = self.rate_limit_blackout_window - t0
                logger.info(
                    '[FCSolar] Rate limit blackout window in place until %s (another %d seconds)',
                      self.rate_limit_blackout_window,
                      remaining_time
                )
        prediction = {}
        for hour in range(48+1):
            prediction[hour] = 0

        # return empty prediction if results have not been obtained
        if not self.results:
            logger.warning('[FCSolar] No results from FC Solar API available')
            raise RuntimeWarning('[FCSolar] No results from FC Solar API available')

        prediction={}
        now = datetime.datetime.now().astimezone(self.timezone)
        current_hour = datetime.datetime(
            now.year, now.month, now.day, now.hour).astimezone(self.timezone)
        result = next(iter(self.results.values()))
        response_time_string = result['message']['info']['time']
        response_time = datetime.datetime.fromisoformat(response_time_string)
        response_timezone = response_time.tzinfo
        for _, result in self.results.items():
            for isotime, value in result['result'].items():
                timestamp = datetime.datetime.fromisoformat(
                    isotime).astimezone(response_timezone)
                diff = timestamp-current_hour
                rel_hour = math.ceil(diff.total_seconds()/3600)-1
                if rel_hour >= 0:
                    if rel_hour in prediction.keys():
                        prediction[rel_hour] += value
                    else:
                        prediction[rel_hour] = value

        max_hour=max(prediction.keys())
        if max_hour < 18 and got_error:
            logger.error('[FCSolar] Less than 18 hours of forecast data. Stopping.')
            raise RuntimeError('[FCSolar] Less than 18 hours of forecast data.')
        #complete hours without production with 0 values
        for h in range(max_hour+1):
            if h not in prediction.keys():
                prediction[h]=0
        #sort output
        output=dict(sorted(prediction.items()))

        return output

    def __get_raw_forecast(self):
        unit: dict
        for unit in self.pvinstallations:
            name = unit['name']
            lat = unit['lat']
            lon = unit['lon']
            dec = unit['declination']  # declination
            az = unit['azimuth']  # 90 =W -90 = E
            kwp = unit['kWp']

            apikey_urlmod=''
            if 'apikey' in unit.keys() and unit['apikey'] is not None:
                apikey_urlmod = unit['apikey'] +"/"# ForecastSolar api
            #legacy naming in config file
            elif 'api' in unit.keys() and unit['api'] is not None:
                apikey_urlmod = unit['api'] +"/" # ForecastSolar api

            horizon_querymod = ''
            if 'horizon' in unit.keys() and unit['horizon'] is not None:
                horizon_querymod = "?horizon=" + unit['horizon']  # ForecastSolar api

            url = (f"https://api.forecast.solar/{apikey_urlmod}estimate/"
                   f"watthours/period/{lat}/{lon}/{dec}/{az}/{kwp}{horizon_querymod}")
            logger.info(
                '[FCSolar] Requesting Information for PV Installation %s', name)


            response = requests.get(url, timeout=60)
            if response.status_code == 200:
                self.results[name] = json.loads(response.text)
            elif response.status_code == 429:
                retry_after = response.headers.get('X-Ratelimit-Retry-At')
                if retry_after:
                    retry_after_timestamp = datetime.datetime.fromisoformat(retry_after)
                    now = datetime.datetime.now().astimezone(self.timezone)
                    retry_seconds = (retry_after_timestamp - now).total_seconds()
                    self.rate_limit_blackout_window = retry_after_timestamp.timestamp()
                    logger.warning(
                      '[ForecastSolar] forecast solar API rate limit exceeded [%s]. '
                      'Retry after %d seconds at %s',
                      response.text,
                      retry_seconds,
                      retry_after_timestamp
                    )
                else:
                    logger.warning(
                        '[ForecastSolar] forecast solar API rate limit exceeded [%s]. '
                        'No retry after information available, dumping headers',
                        response.text
                    )
                    for header, value in response.headers.items():
                        logger.debug('[ForecastSolar 429] Header: %s = %s', header, value)

            else:
                logger.warning(
                    '[ForecastSolar] forecast solar API returned %s - %s',
                      response.status_code, response.text)

if __name__ == '__main__':
    test_pvinstallations = [{'name': 'Nordhalle',
                        'lat': '49.632461',
                        'lon': '8.617459',
                        'declination': '15',
                        'azimuth': '-1',
                        'kWp': '75.695'},
                       {'name': 'Suedhalle',
                           'lat': '49.6319',
                           'lon': '8.6175',
                           'declination': '20',
                           'azimuth': '7',
                           'kWp': '25.030'}]
    fcs=FCSolar( test_pvinstallations, 'Europe/Berlin' , 10)
    print (fcs.get_forecast())

================
File: forecastsolar\forecastsolar_interface.py
================
""" Interface for solar forecast classes """

from abc import ABC, abstractmethod

class ForecastSolarInterface(ABC):
    """ Interface for SolarAPI classes """
    @abstractmethod
    def __init__(self, pvinstallations, timezone, api_delay):
        """ Initialize the SolarAPI class """

    @abstractmethod
    def get_forecast(self) -> dict[int, float]:
        """ Get solar production of all installations up to next 48 hours """

================
File: forecastsolar\solar.py
================
""" Factory for solar forecast providers """

from .forecastsolar_interface import ForecastSolarInterface
from .fcsolar import FCSolar

class ForecastSolar:
    """ Factory for solar forecast providers """
    @staticmethod
    def create_solar_provider(config: dict,
                              timezone,
                              api_delay=0,
                              requested_provider='fcsolarapi') -> ForecastSolarInterface:
        """ Select and configure a solar forecast provider based on the given configuration """

        provider = None
        if requested_provider.lower() == 'fcsolarapi':
            provider = FCSolar(config, timezone, api_delay)
        else:
            raise RuntimeError(f'[ForecastSolar] Unkown provider {requested_provider}')
        return provider

================
File: forecastsolar\__init__.py
================
from .solar import ForecastSolar

================
File: inverter\baseclass.py
================
""" Parent Class for implementing common functions for all inverters """
from .inverter_interface import InverterInterface

class InverterBaseclass(InverterInterface):
    def __init__(self, config):
        self.min_soc = -1
        self.max_soc = -1
        self.mqtt_api = None
        self.capacity = -1
        self.inverter_num = 0

    def get_capacity(self) -> float:
        """ Dummy implementation """
        raise RuntimeWarning("get_capacity not implemented!")

    def get_SOC(self) -> float:   # pylint: disable=invalid-name
        """ Dummy implementation """
        raise RuntimeWarning("get_capacity not implemented!")

    def get_designed_capacity(self) -> float:
        """ Returns the designed maximum capacity of the battery in kWh,
            which does not include MIN_SOC , MAX_SOC or other restrictions.
        """
        return self.get_capacity()

    def get_stored_energy(self) -> float:
        """ Returns the stored energy in the battery in kWh """
        current_soc = self.get_SOC()
        capa = self.get_capacity()
        energy = current_soc/100*capa
        if energy < 0:
            return 0
        return energy

    def get_stored_usable_energy(self) -> float:
        """ Returns the stored energy in the battery in kWh which can be used .
            It reduces the amount by the minimum SOC.
        """
        current_soc = self.get_SOC()
        capa = self.get_capacity()
        energy = (current_soc-self.min_soc)/100*capa
        if energy < 0:
            return 0
        return energy

    def get_usable_capacity(self) -> float:
        """ Returns Capacity which can be used from Battery.
            This value is reduced by MIN_SOC & MAX_SOC limitations.
        """
        usable_capa = (self.max_soc-self.min_soc)/100*self.get_capacity()
        return usable_capa

    def get_max_capacity(self) -> float:
        """ Returns Capacity reduced by MAX_SOC """
        return self.max_soc/100*self.get_capacity()

    def get_free_capacity(self) -> float:
        """ Return Capacity Wh to be chargeable
            this value is reduced by MAX_SOC.
        """
        current_soc = self.get_SOC()
        capa = self.get_capacity()
        free_capa = (self.max_soc-current_soc)/100*capa
        return free_capa

    # Used to implement the mqtt basic topic.
    def __get_mqtt_topic(self) -> str:
        return f'inverters/{self.inverter_num}/'

    def refresh_api_values(self):
        if self.mqtt_api:
            self.mqtt_api.generic_publish(self.__get_mqtt_topic() + 'SOC', self.get_SOC())
            self.mqtt_api.generic_publish(self.__get_mqtt_topic() + 'mode', self.mode)
            self.mqtt_api.generic_publish(self.__get_mqtt_topic() + 'stored_energy', self.get_stored_energy())
            self.mqtt_api.generic_publish(self.__get_mqtt_topic() + 'stored_usable_energy', self.get_stored_usable_energy())
            self.mqtt_api.generic_publish(self.__get_mqtt_topic() + 'free_capacity', self.get_free_capacity())
            self.mqtt_api.generic_publish(self.__get_mqtt_topic() + 'max_capacity', self.get_max_capacity())

    def shutdown(self):
        pass

================
File: inverter\fronius.py
================
"""
This module provides a class `FroniusWR` for handling Fronius GEN24 Inverters.
It includes methods for interacting with the inverter's API, managing battery
configurations, and controlling various inverter settings.

The Fronius Web-API is a bit quirky, which is reflected in the code.

The Web-Login form does send a first request without authentication, which
returns a nonce. This nonce is then used to create a digest for the login
request.

Parts of the information can be called without authentication, but some
settings require authentication. We tackle a 401 as a signal to login again
and retry the request.

Yes, the Webfronted does send the password on each authenticated request hashed
with MD5, nounce etc.

"""
import time
import os
import logging
import json
import hashlib
import requests
from .baseclass import InverterBaseclass

logger = logging.getLogger('__main__').getChild('Fronius')
logger.setLevel(logging.INFO)
logger.info('[Inverter] loading module ')



def hash_utf8(x):
    """Hash a string or bytes object."""
    if isinstance(x, str):
        x = x.encode("utf-8")
    return hashlib.md5(x).hexdigest()


def strip_dict(original):
    """Strip all keys starting with '_' from a dictionary."""
    # return unmodified original if its not a dict
    if not isinstance(original, dict):
        return original
    stripped_copy = {}
    for key in original.keys():
        if not key.startswith('_'):
            stripped_copy[key] = original[key]
    return stripped_copy


TIMEOFUSE_CONFIG_FILENAME = 'config/timeofuse_config.json'
BATTERY_CONFIG_FILENAME = 'config/battery_config.json'


class FroniusWR(InverterBaseclass):
    """ Class for Handling Fronius GEN24 Inverters """

    def __init__(self, config: dict) -> None:
        super().__init__(config)
        self.subsequent_login = False
        self.ncvalue_num = 1
        self.cnonce = "NaN"
        self.login_attempts = 0
        self.address = config['address']
        self.capacity = -1
        self.max_grid_charge_rate = config['max_grid_charge_rate']
        self.max_pv_charge_rate = config['max_pv_charge_rate']
        self.nonce = 0
        self.user = config['user']
        self.password = config['password']
        self.previous_battery_config = self.get_battery_config()
        self.previous_backup_power_config = None
        # default values
        self.max_soc = 100
        self.min_soc = 5
        # Energy Management (EM)
        #  0 - On  (Automatic , Default)
        #  1 - Off (Adjustable)
        self.em_mode = self.previous_battery_config['HYB_EM_MODE']
        # Power in W  on in em_mode = 0
        #   negative = Feed-In (to grid)
        #   positive = Get from grid
        self.em_power = self.previous_battery_config['HYB_EM_POWER']

        self.set_solar_api_active(True)

        if not self.previous_battery_config:
            raise RuntimeError(
                f'[Inverter] failed to load Battery config from Inverter at {self.address}')
        try:
            self.previous_backup_power_config = self.get_powerunit_config()
        except RuntimeError:
            logger.error(
                '[Inverter] failed to load Power Unit config from Inverter (latest).'
            )

        if not self.previous_backup_power_config:
            try:
                self.previous_backup_power_config = self.get_powerunit_config(
                    '1.2'
                    )
                logger.info(
                    '[Inverter] loaded Power Unit config from Inverter (1.2).'
                    )
            except RuntimeError:
                logger.error(
                    '[Inverter] failed to load Power Unit config from Inverter (1.2).'
                )

        if self.previous_backup_power_config:
            self.backup_power_mode = self.previous_backup_power_config[
                'backuppower']['DEVICE_MODE_BACKUPMODE_TYPE_U16']
        else:
            logger.error(
                "[Inverter] Setting backup power mode to 0 as a fallback."
                )
            self.backup_power_mode = 0
            self.previous_backup_power_config = None

        if self.backup_power_mode == 0:
            # in percent
            self.min_soc = self.previous_battery_config['BAT_M0_SOC_MIN']
        else:
            # in percent
            self.min_soc = max(
                self.previous_battery_config['BAT_M0_SOC_MIN'],
                self.previous_battery_config['HYB_BACKUP_RESERVED']
            )
        self.max_soc = self.previous_battery_config['BAT_M0_SOC_MAX']
        self.get_time_of_use()  # save timesofuse
        self.set_allow_grid_charging(True)

    def get_SOC(self):
        path = '/solar_api/v1/GetPowerFlowRealtimeData.fcgi'
        response = self.send_request(path)
        if not response:
            logger.error(
                '[Inverter] Failed to get SOC. Returning default value of 99.0'
                )
            return 99.0
        result = json.loads(response.text)
        soc = result['Body']['Data']['Inverters']['1']['SOC']
        return soc

    def get_battery_config(self):
        """ Get battery configuration from inverter and keep a backup."""
        path = '/config/batteries'
        response = self.send_request(path, auth=True)
        if not response:
            logger.error(
                '[Inverter] Failed to get battery configuration. Returning empty dict'
            )
            return {}

        result = json.loads(response.text)
        # only write file if it does not exist
        if not os.path.exists(BATTERY_CONFIG_FILENAME):
            with open(BATTERY_CONFIG_FILENAME, 'w', encoding='utf-8') as f:
                f.write(response.text)
        else:
            logger.warning(
                '[Inverter] Battery config file already exists. Not writing to %s',
                BATTERY_CONFIG_FILENAME
            )

        return result

    def get_powerunit_config(self, path_version='latest'):
        """ Get additional PowerUnit configuration for backup power.

        Parameters:
            path_version (optional):
                'latest' (default) - get via '/config/powerunit'
                '1.2'              - get via '/config/setup/powerunit'

        Returns: dict with backup power configuration
        """
        if path_version == 'latest':
            path = '/config/powerunit'
        else:
            path = '/config/setup/powerunit'

        response = self.send_request(path, auth=True)
        if not response:
            logger.error(
                '[Inverter] Failed to get power unit configuration. Returning empty dict'
            )
            return {}
        result = json.loads(response.text)
        return result

    def restore_battery_config(self):
        """ Restore the previous battery config from a backup file."""
        settings_to_restore = [
            'BAT_M0_SOC_MAX',
            'BAT_M0_SOC_MIN',
            'BAT_M0_SOC_MODE',
            'HYB_BM_CHARGEFROMAC',
            'HYB_EM_MODE',
            'HYB_EM_POWER',
            'HYB_EVU_CHARGEFROMGRID'
        ]
        settings = {}
        for key in settings_to_restore:
            if key in self.previous_battery_config.keys():
                settings[key] = self.previous_battery_config[key]
            else:
                raise RuntimeError(
                    f"Unable to restore settings. Parameter {key} is missing"
                )
        path = '/config/batteries'
        payload = json.dumps(settings)
        logger.info(
            '[Inverter] Restoring previous battery configuration: %s ',
            payload
        )
        response = self.send_request(
            path, method='POST', payload=payload, auth=True)
        if not response:
            raise RuntimeError('failed to restore battery config')

        response_dict = json.loads(response.text)
        expected_write_successes = settings_to_restore
        for expected_write_success in expected_write_successes:
            if not expected_write_success in response_dict['writeSuccess']:
                raise RuntimeError(f'failed to set {expected_write_success}')
        # Remove after successful restore
        try:
            os.remove(BATTERY_CONFIG_FILENAME)
        except OSError:
            logger.error(
                '[Inverter] could not remove battery config file %s', BATTERY_CONFIG_FILENAME)
        return response

    def set_allow_grid_charging(self, value: bool):
        """ Switches grid charging on (true) or off."""
        if value:
            payload = '{"HYB_EVU_CHARGEFROMGRID": true}'
        else:
            payload = '{"HYB_EVU_CHARGEFROMGRID": false}'
        path = '/config/batteries'
        response = self.send_request(
            path, method='POST', payload=payload, auth=True)
        response_dict = json.loads(response.text)
        expected_write_successes = ['HYB_EVU_CHARGEFROMGRID']
        for expected_write_success in expected_write_successes:
            if not expected_write_success in response_dict['writeSuccess']:
                raise RuntimeError(f'failed to set {expected_write_success}')
        return response

    def set_solar_api_active(self, value: bool):
        """ Switches Solar.API on (true) or off. Solar.API is required to get SOC values."""
        if value:
            payload = '{"SolarAPIv1Enabled": true}'
        else:
            payload = '{"SolarAPIv1Enabled": false}'
        path = '/config/solar_api'
        response = self.send_request(
            path, method='POST', payload=payload, auth=True)
        response_dict = json.loads(response.text)
        expected_write_successes = ['SolarAPIv1Enabled']
        for expected_write_success in expected_write_successes:
            if not expected_write_success in response_dict['writeSuccess']:
                raise RuntimeError(f'failed to set {expected_write_success}')
        return response

    def set_wr_parameters(self, minsoc, maxsoc, allow_grid_charging, grid_power):
        """set power at grid-connection point negative values for Feed-In"""
        path = '/config/batteries'
        if not isinstance(allow_grid_charging , bool):
            raise RuntimeError(
                f'Expected type: bool actual type: {type(allow_grid_charging)}')

        grid_power = int(grid_power)
        minsoc = int(minsoc)
        maxsoc = int(maxsoc)

        if not 0 <= grid_power <= self.max_grid_charge_rate:
            raise RuntimeError(f'gridpower out of allowed limits {grid_power}')

        if minsoc > maxsoc:
            raise RuntimeError('Min SOC needs to be higher than Max SOC')

        if minsoc < self.min_soc:
            raise RuntimeError(f'Min SOC not allowed below {self.min_soc}')

        if maxsoc > self.max_soc:
            raise RuntimeError(f'Max SOC not allowed above {self.max_soc}')

        parameters = {'HYB_EVU_CHARGEFROMGRID': allow_grid_charging,
                      'HYB_EM_POWER': grid_power,
                      'HYB_EM_MODE': 1,
                      'BAT_M0_SOC_MIN': minsoc,
                      'BAT_M0_SOC_MAX': maxsoc,
                      'BAT_M0_SOC_MODE': 'manual'
                      }

        payload = json.dumps(parameters)
        logger.info('[Inverter] Setting battery parameters: %s', payload)

        response = self.send_request(
            path, method='POST', payload=payload, auth=True)
        if not response:
            logger.error(
                '[Inverter] Failed to set parameters. No response from server'
                )
            return response
        response_dict = json.loads(response.text)
        for expected_write_success in parameters.keys():
            if not expected_write_success in response_dict['writeSuccess']:
                raise RuntimeError(f'failed to set {expected_write_success}')
        return response

    def get_time_of_use(self):
        """ Get time of use configuration from inverter and keep a backup."""
        response = self.send_request('/config/timeofuse', auth=True)
        if not response:
            return None

        result = json.loads(response.text)['timeofuse']
        # only write file if it does not exist
        if not os.path.exists(TIMEOFUSE_CONFIG_FILENAME):
            with open(TIMEOFUSE_CONFIG_FILENAME, 'w', encoding='utf-8') as f:
                f.write(json.dumps(result))
        else:
            logger.warning(
                '[Inverter] Time of use config file already exists. Not writing to %s',
                TIMEOFUSE_CONFIG_FILENAME
            )

        return result

    def set_mode_avoid_discharge(self):
        """ Set the inverter to avoid discharging the battery."""
        timeofuselist = [{'Active': True,
                          'Power': int(0),
                          'ScheduleType': 'DISCHARGE_MAX',
                          "TimeTable": {"Start": "00:00", "End": "23:59"},
                          "Weekdays":
                               {"Mon": True,
                                "Tue": True,
                                "Wed": True,
                                "Thu": True,
                                "Fri": True,
                                "Sat": True,
                                "Sun": True}
                          }]
        return self.set_time_of_use(timeofuselist)

    def set_mode_allow_discharge(self):
        """ Set the inverter to discharge the battery."""
        timeofuselist = []
        if self.max_pv_charge_rate > 0:
            timeofuselist = [{'Active': True,
                              'Power': int(self.max_pv_charge_rate),
                              'ScheduleType': 'CHARGE_MAX',
                              "TimeTable": {"Start": "00:00", "End": "23:59"},
                              "Weekdays":
                                    {"Mon": True,
                                     "Tue": True,
                                     "Wed": True,
                                     "Thu": True,
                                     "Fri": True,
                                     "Sat": True,
                                     "Sun": True}
                              }]
        response = self.set_time_of_use(timeofuselist)

        return response

    def set_mode_force_charge(self, chargerate=500):
        """ Set the inverter to charge the battery with a specific power from GRID."""
        # activate timeofuse rules
        chargerate = min( chargerate, self.max_grid_charge_rate)
        timeofuselist = [{'Active': True,
                          'Power': int(chargerate),
                          'ScheduleType': 'CHARGE_MIN',
                          "TimeTable": {"Start": "00:00", "End": "23:59"},
                          "Weekdays":
                                {"Mon": True,
                                 "Tue": True,
                                 "Wed": True,
                                 "Thu": True,
                                 "Fri": True,
                                 "Sat": True,
                                 "Sun": True}
                          }]
        return self.set_time_of_use(timeofuselist)

    def restore_time_of_use_config(self):
        """ Restore the previous time of use config from a backup file."""
        try:
            with open(TIMEOFUSE_CONFIG_FILENAME, 'r', encoding="utf-8") as f:
                time_of_use_config_json = f.read()
        except OSError:
            logger.error('[Inverter] could not restore timeofuse config')
            return

        try:
            time_of_use_config = json.loads(time_of_use_config_json)
        except:  # pylint: disable=bare-except
            logger.error(
                '[Inverter] could not parse timeofuse config from %s',
                TIMEOFUSE_CONFIG_FILENAME
            )
            return

        stripped_time_of_use_config = []
        for listitem in time_of_use_config:
            new_item = {}
            new_item['Active'] = listitem['Active']
            new_item['Power'] = listitem['Power']
            new_item['ScheduleType'] = listitem['ScheduleType']
            new_item['TimeTable'] = {
                'Start': listitem['TimeTable']['Start'],
                'End': listitem['TimeTable']['End']
            }
            weekdays = {}
            for day in ['Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun']:
                weekdays[day] = listitem['Weekdays'][day]
            new_item['Weekdays'] = weekdays
            stripped_time_of_use_config.append(new_item)

        self.set_time_of_use(stripped_time_of_use_config)
        # After restoring the time of use config, delete the backup
        try:
            os.remove(TIMEOFUSE_CONFIG_FILENAME)
        except OSError:
            logger.error(
                '[Inverter] could not remove timeofuse config file %s', TIMEOFUSE_CONFIG_FILENAME
                )

    def set_time_of_use(self, timeofuselist):
        """ Get the planned battery charge/discharge schedule."""
        config = {
            'timeofuse': timeofuselist
        }
        payload = json.dumps(config)
        response = self.send_request(
            '/config/timeofuse', method='POST', payload=payload, auth=True
            )
        response_dict = json.loads(response.text)
        expected_write_successes = ['timeofuse']
        for expected_write_success in expected_write_successes:
            if not expected_write_success in response_dict['writeSuccess']:
                raise RuntimeError(f'failed to set {expected_write_success}')
        return response

    def get_capacity(self):
        """ Get the full and raw capacity of the battery in Wh."""
        if self.capacity >= 0:
            return self.capacity

        response = self.send_request(
            '/solar_api/v1/GetStorageRealtimeData.cgi')
        if not response:
            logger.warning(
                '[Inverter] capacity request failed. Returning default value'
            )
            return 1000
        result = json.loads(response.text)
        capacity = result['Body']['Data']['0']['Controller']['DesignedCapacity']
        self.capacity = capacity
        return capacity

    def send_request (self, path, method='GET', payload="", params=None, headers=None, auth=False):
        """Send a HTTP REST request to the inverter.

            auth = This request needs to be run with authentication.
            is_login = This request is a login request. Do not retry on 401.
        """
        logger.debug("[Inverter] Sending request to %s", path)
        if not headers:
            headers = {}
        for i in range(2):
            # Try tp send the request, if it fails, try to login and resend
            response = self.__send_one_http_request(path, method, payload, params, headers, auth)
            if response.status_code == 200:
                if auth:
                    self.__retrieve_auth_from_response(response)
                return response
            # 401 - unauthorized , relogin
            # 403 - is forbidden, what happens at 01.00 in the night
            if response.status_code in( 401, 403 ):
                self.__retrieve_auth_from_response(response)
                self.login()
            else:
                raise RuntimeError(
                    f"[Inverter] Request {i} failed with {response.status_code}-"
                    f"{response.reason}. \n"
                    f"\t path:{path}, \n\tparams:{params} \n\theaders {headers} \n"
                    f"\tnonce {self.nonce} \n"
                    f"\tpayload {payload}"
                )
        return None

    def __send_one_http_request(self, path, method='GET', payload="",
                                        params=None, headers=None, auth=False):
        """ Send one HTTP Request to the backend.
            This method does not handle application errors, only connection errors.
        """
        if not headers:
            headers = {}
        url = 'http://' + self.address + path
        fullpath = path
        if params:
            fullpath += '?' + \
                "&".join(
                    [f'{k+"="+str(params[k])}' for k in params.keys()])
        if auth:
            headers['Authorization'] = self.get_auth_header(
                method=method, path=fullpath)

        for i in range(3):
            # 3 retries if connection can't be established
            try:
                response = requests.request(
                                    method=method,
                                    url=url,
                                    params=params,
                                    headers=headers,
                                    data=payload,
                                    timeout=30
                                )
                return response
            except requests.exceptions.ConnectionError as err:
                logger.error(
                    "[Inverter] Connection to Inverter failed on %s. (%d) "
                    "Retrying in 60 seconds, Error %s",
                    self.address,
                    i,
                    err
                    )
                time.sleep(60)

        logger.error( '[Inverter] Request failed without response.')
        raise RuntimeError(
                f"\turl:{url}, \n\tparams:{params} \n\theaders {headers} \n"
                f"\tnonce {self.nonce} \n"
                f"\tpayload {payload}"
            )

    def login(self):
        """Login to Fronius API"""
        logger.debug("[Inverter] Logging in")
        path = '/commands/Login'
        self.cnonce = "NaN"
        self.ncvalue_num = 1
        self.login_attempts = 0
        for i in range(3):
            self.login_attempts += 1
            response = self.__send_one_http_request(path, auth=True)
            if response.status_code == 200:
                self.subsequent_login = True
                logger.info('[Inverter] Login successful %s', response)
                logger.debug("[Inverter] Response: %s", response.headers)
                self.__retrieve_auth_from_response(response)
                self.login_attempts = 0
                return

            logger.error(
                '[Inverter] Login -%d- failed, Response: %s', i, response)
            logger.error('[Inverter] Response-raw: %s', response.raw)
            if self.subsequent_login:
                logger.info(
                    "[Inverter] Retrying login in 10 seconds")
                time.sleep(10)
        if self.login_attempts  >= 3:
            logger.info(
                '[Inverter] Login failed 3 times .. aborting'
                )
            raise RuntimeError(
                '[Inverter] Login failed repeatedly .. wrong credentials?'
                )

    def logout(self):
        """Logout from Fronius API"""
        path = '/commands/Logout'
        response = self.send_request(path, auth=True)
        if not response:
            logger.warning('[Inverter] Logout failed. No response from server')
        if response.status_code == 200:
            logger.info('[Inverter] Logout successful')
        else:
            logger.info('[Inverter] Logout failed')
        return response

    def __retrieve_auth_from_response(self, response):
        """Get & store the authentication parts from response auth header.
            - nc
            - cnonce
            - nonce
        """
        auth_dict = self.__split_response_auth_header(response)
        if auth_dict.get('nc'):
            self.ncvalue_num = int(auth_dict['nc']) + 1
        else:
            self.ncvalue_num = 1
        if auth_dict.get('cnonce'):
            self.cnonce = auth_dict['cnonce']
        else:
            self.cnonce = "NaN"
        if auth_dict.get('nonce'):
            self.nonce = auth_dict['nonce']

    def __split_response_auth_header(self, response):
        """ Split the response header into a dictionary."""
        auth_dict = {}
        # stupid API bug: nonce headers with different capitalization at different end points
        if 'X-WWW-Authenticate' in response.headers:
            auth_string = response.headers['X-WWW-Authenticate']
        elif 'X-Www-Authenticate' in response.headers:
            auth_string = response.headers['X-Www-Authenticate']
        elif 'Authentication-Info' in response.headers:
            auth_string = response.headers['Authentication-Info']
        else:
            # Return an empty dict to work with Fronius below 1.35.4-1
            logger.debug(
                '[Inverter] No authentication header found in response')
            return auth_dict

        auth_list = auth_string.replace(" ", "").replace('"', '').split(',')
        logger.debug("[Inverter] Authentication header: %s", auth_list)
        auth_dict = {}
        for item in auth_list:
            key, value = item.split("=")
            auth_dict[key] = value
            logger.debug("[Inverter] %s: %s", key, value)
        return auth_dict

    def get_auth_header(self, method, path) -> str:
        """Create the Authorization header for the request."""
        nonce = self.nonce
        realm = 'Webinterface area'
        ncvalue = f"{self.ncvalue_num:08d}"
        cnonce = self.cnonce
        user = self.user
        password = self.password
        if len(self.user) < 4:
            raise RuntimeError("User needed for Authorization")
        if len(self.password) < 4:
            raise RuntimeError("Password needed for Authorization")

        a1 = f"{user}:{realm}:{password}"
        a2 = f"{method}:{path}"
        ha1 = hash_utf8(a1)
        ha2 = hash_utf8(a2)
        noncebit = f"{nonce}:{ncvalue}:{cnonce}:auth:{ha2}"
        respdig = hash_utf8(f"{ha1}:{noncebit}")
        auth_header  = f'Digest username="{user}", realm="{realm}", nonce="{nonce}", uri="{path}", '
        auth_header += f'algorithm="MD5", qop=auth, nc={ncvalue}, cnonce="{cnonce}", '
        auth_header += f'response="{respdig}"'
        return auth_header

    def __set_em(self, mode = None, power = None):
        """ Change Energy Management """
        settings = {}
        settings = {
            'HYB_EM_MODE': self.em_mode,
            'HYB_EM_POWER': self.em_power
        }

        if mode is not None:
            settings['HYB_EM_MODE'] = mode
        if power is not None:
            settings['HYB_EM_POWER'] = power

        path = '/config/batteries'
        payload = json.dumps(settings)
        logger.info(
            '[Inverter] Setting EM mode %s , power %s',
            mode,
            power
        )
        response = self.send_request(
            path, method='POST', payload=payload, auth=True)
        if not response:
            raise RuntimeError('Failed to set EM')

    def set_em_power(self, power):
        """ Change Energy Manangement Power
            positive = get from grid
            negative = feed to grid
        """
        self.__set_em(power=power)
        self.em_power = power
        if self.mqtt_api:
            self.mqtt_api.generic_publish(
                self.__get_mqtt_topic() + 'em_power', power)

    def set_em_mode(self, mode):
        """ Change Energy Manangement mode."""
        self.__set_em(mode=mode)
        self.em_mode = mode
        if self.mqtt_api:
            self.mqtt_api.generic_publish(
                self.__get_mqtt_topic() + 'em_mode', mode)

    def shutdown(self):
        """Change back batcontrol changes."""
        logger.info('[Inverter] Reverting batcontrol created config changes')
        self.restore_battery_config()
        self.restore_time_of_use_config()
        self.logout()

    def activate_mqtt(self, api_mqtt_api):
        """
        Activates MQTT for the inverter.

        This function starts the API functions and publishes all internal values via MQTT.
        The MQTT topic is: base_topic + '/inverters/0/'

        Parameters that can be set via MQTT:
        - max_grid_charge_rate (int): Maximum power in W that can be
                                          used to load the battery from the grid.
        - max_pv_charge_rate (int): Maximum power in W that can be
                                          used to load the battery from the PV.

        Args:
            api_mqtt_api: The MQTT API instance to be used for registering callbacks.

        """
        self.mqtt_api = api_mqtt_api
        # /set is appended to the topic
        self.mqtt_api.register_set_callback(self.__get_mqtt_topic(
        ) + 'max_grid_charge_rate', self.api_set_max_grid_charge_rate, int)
        self.mqtt_api.register_set_callback(self.__get_mqtt_topic(
        ) + 'max_pv_charge_rate', self.api_set_max_pv_charge_rate, int)
        self.mqtt_api.register_set_callback(self.__get_mqtt_topic(
        ) + 'em_mode', self.api_set_em_mode, int)
        self.mqtt_api.register_set_callback(self.__get_mqtt_topic(
        ) + 'em_power', self.api_set_em_power, int)

    def refresh_api_values(self):
        """ Publishes all values to mqtt."""
        if self.mqtt_api:
            self.mqtt_api.generic_publish(
                self.__get_mqtt_topic() + 'SOC', self.get_SOC())
            self.mqtt_api.generic_publish(
                self.__get_mqtt_topic() + 'stored_energy', self.get_stored_energy())
            self.mqtt_api.generic_publish(
                self.__get_mqtt_topic() + 'free_capacity', self.get_free_capacity())
            self.mqtt_api.generic_publish(
                self.__get_mqtt_topic() + 'max_capacity', self.get_max_capacity())
            self.mqtt_api.generic_publish(self.__get_mqtt_topic(
            ) + 'usable_capacity', self.get_usable_capacity())
            self.mqtt_api.generic_publish(self.__get_mqtt_topic(
            ) + 'max_grid_charge_rate', self.max_grid_charge_rate)
            self.mqtt_api.generic_publish(self.__get_mqtt_topic(
            ) + 'max_pv_charge_rate', self.max_pv_charge_rate)
            self.mqtt_api.generic_publish(
                self.__get_mqtt_topic() + 'min_soc', self.min_soc)
            self.mqtt_api.generic_publish(
                self.__get_mqtt_topic() + 'max_soc', self.max_soc)
            self.mqtt_api.generic_publish(
                self.__get_mqtt_topic() + 'capacity', self.get_capacity())
            self.mqtt_api.generic_publish(
                self.__get_mqtt_topic() + 'em_mode' , self.em_mode)
            self.mqtt_api.generic_publish(
                self.__get_mqtt_topic() + 'em_power' , self.em_power)

    def api_set_max_grid_charge_rate(self, max_grid_charge_rate: int):
        """ Set the maximum power in W that can be used to load the battery from the grid."""
        if max_grid_charge_rate < 0:
            logger.warning(
                '[Inverter] API: Invalid max_grid_charge_rate %sW',
                max_grid_charge_rate
            )
            return
        logger.info(
            '[Inverter] API: Setting max_grid_charge_rate: %.1fW',
            max_grid_charge_rate
        )
        self.max_grid_charge_rate = max_grid_charge_rate

    def api_set_max_pv_charge_rate(self, max_pv_charge_rate: int):
        """ Set the maximum power in W that can be used to load the battery from the PV."""
        if max_pv_charge_rate < 0:
            logger.warning(
                '[Inverter] API: Invalid max_pv_charge_rate %s',
                max_pv_charge_rate
            )
            return
        logger.info(
            '[Inverter] API: Setting max_pv_charge_rate: %.1fW',
            max_pv_charge_rate
        )
        self.max_pv_charge_rate = max_pv_charge_rate

    def api_set_em_mode(self, em_mode: int):
        """ Set the Energy Management Mode."""
        if not isinstance(em_mode , int):
            logger.warning(
                '[Inverter] API: Invalid type em_mode %s',
                em_mode
            )
            return
        if em_mode < 0 or em_mode > 2:
            logger.warning(
                '[Inverter] API: Invalid em_mode %s',
                em_mode
            )
            return
        logger.info(
            '[Inverter] API: Setting em_mode: %s',
            em_mode
        )
        self.set_em_mode(em_mode)

    def api_set_em_power(self, em_power: int):
        """ Change EnergeManagement Offset
            positive = get from grid
            negative = feed to grid
        """
        if not isinstance(em_power , int):
            logger.warning(
                '[Inverter] API: Invalid type em_power %s',
                em_power
            )
            return
        logger.info(
            '[Inverter] API: Setting em_power: %s',
            em_power
        )
        self.set_em_power(em_power)

    def __get_mqtt_topic(self) -> str:
        """ Used to implement the mqtt basic topic."""
        return f'inverters/{self.inverter_num}/'

================
File: inverter\inverter.py
================
""" Factory for inverter providers """

from .inverter_interface import InverterInterface



class Inverter:
    """ Factory for inverter providers """
    # Instances of the inverter classes are created here
    num_inverters = 0
    @staticmethod
    def create_inverter(config: dict) -> InverterInterface:
        """ Select and configure an inverter based on the given configuration """
        # renaming of parameters max_charge_rate -> max_grid_charge_rate
        if not 'max_grid_charge_rate' in config.keys():
            config['max_grid_charge_rate'] = config['max_charge_rate']

        # introducing parameter max_pv_charge_rate. Assign default value here,
        # in case there is no value defined in the config file to avoid a KeyError
        if not 'max_pv_charge_rate' in config.keys():
            config['max_pv_charge_rate'] = 0

        inverter = None

        if config['type'].lower() == 'fronius_gen24':
            from .fronius import FroniusWR

            iv_config = {
                'address': config['address'],
                'user': config['user'],
                'password': config['password'],
                'max_grid_charge_rate': config['max_grid_charge_rate'],
                'max_pv_charge_rate': config['max_pv_charge_rate']
            }
            inverter=FroniusWR(iv_config)
        elif config['type'].lower() == 'testdriver':
            from .testdriver import Testdriver
            iv_config = {
                'max_grid_charge_rate': config['max_grid_charge_rate']
            }
            inverter=Testdriver(iv_config)
        else:
            raise RuntimeError(f'[Inverter] Unkown inverter type {config["type"]}')

        inverter.inverter_num = Inverter.num_inverters
        Inverter.num_inverters += 1
        return inverter

================
File: inverter\inverter_interface.py
================
""" Interface for inverter classes """

from abc import ABC, abstractmethod

class InverterInterface(ABC):
    """ Interface for Inverter classes """
    @abstractmethod
    def __init__(self, dict_config: dict):
        """ Initialize the Inverter class """

    @abstractmethod
    def set_mode_force_charge(self, chargerate: float):
        """ Set the inverter to force charge mode """

    @abstractmethod
    def set_mode_avoid_discharge(self):
        """ Set the inverter to allow discharge mode """

    @abstractmethod
    def set_mode_allow_discharge(self):
        """ Set the inverter to avoid discharge mode """

    @abstractmethod
    def get_stored_energy(self) -> float:
        """ Get the stored energy in the inverter.
        This value does not account MIN_SOC and MAX_SOC values.
        Returns:
            float: The stored energy in the inverter in Wh.
        """

    @abstractmethod
    def get_stored_usable_energy(self) -> float:
        """ Get the stored energy in the inverter.
        It reduces the amount by the minimum SOC.
        Returns:
            float: The stored energy in the inverter in Wh.
        """

    @abstractmethod
    def get_capacity(self) -> float:
        """ Get the maximum capacity of the inverter.
        This value does not account MIN_SOC and MAX_SOC values.
        Returns:
            float: The maximum capacity of the inverter in Wh.
        """

    @abstractmethod
    def get_free_capacity(self) -> float:
        """ Get the free capacity of the inverter.
            This value is reduced by MAX_SOC
        Returns:
            float: The free capacity of the inverter in Wh.
        """

    @abstractmethod
    def get_max_capacity(self) -> float:
        """ Get the maximum capacity of the inverter.
        This value is reduced by MAX_SOC.
        Returns:
            float: The maximum capacity of the inverter in Wh.
        """
    @abstractmethod
    def get_SOC(self) -> float:  # pylint: disable=invalid-name
        """ Get the state of charge of the inverter in percentage.
        Returns:
            float: The SOC of the inverter in percentage.
        """

    @abstractmethod
    def activate_mqtt(self, api_mqtt_api: object):
        """ Activate the MQTT connection for the inverter """

    @abstractmethod
    def refresh_api_values(self):
        """ Refresh the values for the API """

    @abstractmethod
    def shutdown(self):
        """ Class to bring the inverter into a consistent state while
            batcontrol is shutting down """

================
File: inverter\testdriver.py
================
import logging
from .baseclass import InverterBaseclass
from .inverter_interface import InverterInterface

logger = logging.getLogger('__main__')
logger.info('[Testdriver] loading module')

#from .fronius import InverterBaseclass

# Testdriver to simulate a inverter for local testing.
#
# Following values can be set via MQTT:
# - SOC (int): State of charge in percent
#            : <mqtt_topic>/inverters/0/SOC/set


class Testdriver(InverterBaseclass):
    def __init__(self, config):
        super().__init__(config)
        self.max_grid_charge_rate=config['max_grid_charge_rate']
        self.installed_capacity=11000 # in Wh
        self.SOC=69.0 # static simulation SOC in percent
        self.min_soc=8 # in percent
        self.max_soc=100 # in percent
        self.mode='allow_discharge'
        self.mqtt_api = None

    def set_mode_force_charge(self,chargerate=500):
        self.mode='force_charge'

    def set_mode_allow_discharge(self):
        self.mode='allow_discharge'

    def set_mode_avoid_discharge(self):
        self.mode='avoid_discharge'

    def get_capacity(self):
        return self.installed_capacity

    def get_SOC(self):
        return self.SOC

    def api_set_SOC(self, SOC:int):
        if SOC < 0 or SOC > 100:
            logger.warning(f'[BatCtrl] testdriver API: Invalid SOC {SOC}')
            return
        logger.info(f'[BatCtrl] testdriver API: Setting SOC: {SOC}%')
        self.SOC = SOC

    def activate_mqtt(self, api_mqtt_api):  # no type here to prevent the need of loading mqtt_api
        import mqtt_api
        self.mqtt_api = api_mqtt_api
        # /set is appended to the topic
        self.mqtt_api.register_set_callback(self.__get_mqtt_topic() + 'SOC', self.api_set_SOC, int)

    def refresh_api_values(self):
        super().refresh_api_values()
        if self.mqtt_api:
            self.mqtt_api.generic_publish(self.__get_mqtt_topic() + 'mode', self.mode)

    def shutdown(self):
        pass

    def __get_mqtt_topic(self) -> str:
        return f'inverters/{self.inverter_num}/'

================
File: inverter\__init__.py
================
from .inverter import Inverter

================
File: logfilelimiter\logfilelimiter.py
================
#! /usr/bin/env python
"""
This module provides a LogFileLimiter class that limits the size of a log file by
deleting the oldest lines.

Classes:
    LogFileLimiter: A class that limits the size of a log file by deleting the
    oldest lines.

"""
import os
import logging
logger = logging.getLogger('__main__')
logger.info('[LogFileLimiter] loading module')


class LogFileLimiter:
    """ A class that limits the size of a log file by deleting the oldest lines. """
    def __init__(self, path, max_size):
        """
        Initialize the LogFileLimiter class with the path to the file and
        the maximum size in kilobytes.

        :param path: Path to the log file.
        :param max_size: Maximum file size in kilobytes.
        """
        self.path = path
        self.max_size = max_size * 1024  # Convert kilobytes to bytes

    def prune(self, prune_factor):
        """
        Reduces the file size by deleting the earliest lines.
        :param prune_factor: The fraction of total lines to delete.
        """
        if prune_factor < 0 or prune_factor > 1:
            raise ValueError("Prune factor must be between 0 and 1.")

        logger.info(
            '[LogFileLimiter] File %s is too large. File will be pruned by %.2f %%',
            self.path,
            prune_factor * 100
        )
        with open(self.path, 'r+', encoding='UTF-8') as file:
            lines = file.readlines()
            file.seek(0)
            file.truncate()
            file.writelines(lines[int(len(lines) * prune_factor):])

    def run(self):
        """
        Checks the file size and calls the prune method if necessary.
        """
        file_size = os.path.getsize(self.path)
        if file_size > self.max_size:
            # Determine the prune factor, at least 10%
            prune_factor = max(0.1, 1 - self.max_size / file_size)
            self.prune(prune_factor)

# Example usage
if __name__ == "__main__":
    limiter = LogFileLimiter("test copy.log", 20)  # Maximum size of 20 KB
    limiter.run()

================
File: logfilelimiter\__init__.py
================
from .logfilelimiter import LogFileLimiter
